<!DOCTYPE html>
<html><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:media="http://search.yahoo.com/mrss/" version="2.0"><channel><title>Python - Steady Monkey</title><description>Whatever thoughts out of Borjan's head.</description><link>http://localhost:3050/</link><image><url>http://localhost:3050/favicon.png</url><title>Python - Steady Monkey</title><link>http://localhost:3050/</link></image><generator>Ghost 2.37</generator><lastBuildDate>Sun, 05 Jan 2020 18:49:43 GMT</lastBuildDate><atom:link href="http://localhost:3050/tag/python/rss/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title>A reentrant context manager in Python</title><description>A Python context manager caters for the boilerplate wrapping a resource to offer safety and convenient (re-)use. Upgrading a context manager to be reentrant is a simple and efficient way to allow a scope to be shared, without changing the context semantics.</description><link>http://localhost:3050/a-reentrant-context-manager-in-python/</link><guid isPermaLink="false">5e08ad581e44010001be4de4</guid><category>Python</category><dc:creator>Borjan Tchakaloff</dc:creator><pubDate>Sun, 05 Jan 2020 18:43:10 GMT</pubDate><content:encoded>&lt;p&gt;A Python context manager caters for the boilerplate wrapping a resource to offer safety and convenient (re-)use. This protocol ensures that once the context is initialised, it will be torn down whatever happens. Examples of resource handling are input/output operations, session management, thread locking, etc. In this article, we will take a focus peek at one "&lt;a href="https://www.python.org/dev/peps/pep-0020/#the-zen-of-python"&gt;honking great idea&lt;/a&gt;": a &lt;strong&gt;reentrant context manager&lt;/strong&gt;.&lt;/p&gt;&lt;p&gt;There has been &lt;a href="http://johnj.com/intro-to-context-managers-in-python.html"&gt;many&lt;/a&gt; &lt;a href="https://book.pythontips.com/en/latest/context_managers.html"&gt;articles&lt;/a&gt; and pages of &lt;a href="https://en.wikibooks.org/wiki/Python_Programming/Context_Managers"&gt;documentation&lt;/a&gt; to explain why context managers are a good thing, and why you would want to &lt;a href="https://jeffknupp.com/blog/2016/03/07/python-with-context-managers/"&gt;always&lt;em&gt; &lt;/em&gt;handle your resources&lt;/a&gt; with them.&lt;/p&gt;&lt;p&gt;Drawing from classic computer science principles, we propose here to extend the &lt;em&gt;context manager&lt;/em&gt; with the &lt;em&gt;reentrant&lt;/em&gt; principle to achieve a simple, yet powerful, resource management.&lt;/p&gt;&lt;h2 id="our-case-study-a-data-store"&gt;Our case study: a data store&lt;/h2&gt;&lt;p&gt;Suppose you are writing a library for a (remote) service. It could be that you want to offer a nice Python interface for your own service, or simply that you want to abstract the service itself from your business code — a &lt;a href="https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html"&gt;sound idea&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;Our example service is a data store. A user can push, and then pull, arbitrary data from it. Any data that is stored there is associated to a unique identifier. Later, and at one's request, the identifier can be used to pull the data out of the store once and for all. The store will forget about that piece of data.&lt;/p&gt;&lt;!--kg-card-begin: code--&gt;&lt;pre&gt;&lt;code class="language-python"&gt;# datastore.py
from abc import ABC, abstractmethod


Content = bytes
Identifier = str


class Datastore(ABC):

    @abstractmethod
    def push(self, content: Content) -&amp;gt; Identifier:
        ...

    @abstractmethod
    def pull(self, identifier: Identifier) -&amp;gt; Content:
        ...
&lt;/code&gt;&lt;/pre&gt;&lt;!--kg-card-end: code--&gt;&lt;p&gt;The interface is simple and clean. &lt;code&gt;Datastore&lt;/code&gt; is an &lt;a href="https://docs.python.org/3/glossary.html#term-abstract-base-class"&gt;abstract class&lt;/a&gt; with two public (abstract) methods.&lt;/p&gt;&lt;p&gt;Let's create an in-memory datastore to mock the service and trace the interface calls:&lt;/p&gt;&lt;!--kg-card-begin: code--&gt;&lt;pre&gt;&lt;code class="language-python"&gt;# mock_datastore.py
import logging
from uuid import uuid4

from datastore import Content, Datastore, Identifier


class InMemoryDatastore(Datastore):

    _log = logging.getLogger('InMemoryDatastore')
    _store = []

    def push(self, content):
        identifier = str(uuid4())
        self._log.debug('PUSH: %s with %s bytes', identifier, len(content))
        self._store[identifier] = content
        return identifier

    def pull(self, identifier):
        if identifier not in self._store:
            raise KeyError(f"Unknown identifier {identifier!r}")
        self._log.debug(f'PULL: %s', identifier)
        content = self._store.pop(identifier)
        return content
&lt;/code&gt;&lt;/pre&gt;&lt;!--kg-card-end: code--&gt;&lt;p&gt;We can now store and retrieve content from a datastore:&lt;/p&gt;&lt;!--kg-card-begin: code--&gt;&lt;pre&gt;&lt;code class="language-python"&gt;&amp;gt;&amp;gt;&amp;gt; import logging
&amp;gt;&amp;gt;&amp;gt; logging.basicConfig(level=logging.DEBUG)
&amp;gt;&amp;gt;&amp;gt; from mock_datastore import InMemoryDatastore as MockDatastore
&amp;gt;&amp;gt;&amp;gt; client = MockDatastore()
&amp;gt;&amp;gt;&amp;gt; i = client.push(b'an entry')
DEBUG:InMemoryDatastore:PUSH: 53d387c9-8d96-4ca8-a1c5-f6d5efffc572 with 8 bytes
&amp;gt;&amp;gt;&amp;gt; client.pull(i)
DEBUG:InMemoryDatastore:PULL: 53d387c9-8d96-4ca8-a1c5-f6d5efffc572
b'an entry'
&lt;/code&gt;&lt;/pre&gt;&lt;!--kg-card-end: code--&gt;&lt;h2 id="-for-authenticated-users"&gt;… for authenticated users&lt;/h2&gt;&lt;p&gt;Say there is a new requirement: all actions undertook against the data store must be authenticated. The client interface should handle this and provide a construct to deal with &lt;em&gt;sessions&lt;/em&gt;. There is no need for the interface consumer to have to manually log in and out, we will not change the &lt;code&gt;Datastore&lt;/code&gt; interface. The library we are writing is supposed to &lt;em&gt;help&lt;/em&gt; the consumer, not clutter its interface.&lt;/p&gt;&lt;p&gt;We will define the authentication methods as "private/protected" and use them to push and pull data to the data store, from the implementation classes themselves. To avoid repeating ourselves, we simply define a new interface:&lt;/p&gt;&lt;!--kg-card-begin: code--&gt;&lt;pre&gt;&lt;code class="language-python"&gt;# authenticated_datastore.py

from abc import abstractmethod
from contextlib import contextmanager

from datastore import Datastore


AuthToken = str


class AuthenticatedDatastore(Datastore):

    @abstractmethod
    def push(self, content):
        ...

    @abstractmethod
    def pull(self, identifier):
        ...

    @abstractmethod
    def _login(self, credentials) -&amp;gt; AuthToken:
        ...

    @abstractmethod
    def _logout(self, token: AuthToken):
        ...
&lt;/code&gt;&lt;/pre&gt;&lt;!--kg-card-end: code--&gt;&lt;p&gt;Good programmers are lazy, they say. Programmers always want to make things silly simple and efficient. I could not agree more, especially if there is an exposed interface at play.&lt;/p&gt;&lt;p&gt;The implementation classes have to remember to call &lt;code&gt;_logout()&lt;/code&gt; every time they call &lt;code&gt;_login()&lt;/code&gt;. What happens to us when we burden ourselves with hand-woven resource management? Things break, memory leaks, and we become sad.&lt;/p&gt;&lt;p&gt;The authentication as we just defined it &lt;strong&gt;is a resource&lt;/strong&gt; that we manage: we have to create (&lt;em&gt;to log in&lt;/em&gt;) and destroy (&lt;em&gt;to log out&lt;/em&gt;) each instance we handle (&lt;em&gt;a session&lt;/em&gt;). Let's take a look at a nifty solution Python offers us: the context manager.&lt;/p&gt;&lt;h2 id="what-a-context-manager-is-by-example"&gt;What a context manager is, by example&lt;/h2&gt;&lt;p&gt;The Python documentation describes &lt;a href="https://docs.python.org/3/reference/datamodel.html#context-managers"&gt;a context manager&lt;/a&gt; as:&lt;/p&gt;&lt;blockquote&gt;[…] an object that defines the runtime context to be established when executing a &lt;code&gt;with&lt;/code&gt; statement. The context manager handles the entry into, and the exit from, the desired runtime context for the execution of the block of code.&lt;/blockquote&gt;&lt;p&gt;Said differently, the scope of a context manager is tied to an object life-cycle. But instead of the regular &lt;em&gt;initialisation&lt;/em&gt; and &lt;em&gt;destruction&lt;/em&gt; of the object, a different protocol is used (aptly named… &lt;a href="https://docs.python.org/3/library/stdtypes.html#typecontextmanager"&gt;Context Manager&lt;/a&gt;). It defines the interface for &lt;em&gt;entry&lt;/em&gt; and &lt;em&gt;exit&lt;/em&gt; of the scope.&lt;/p&gt;&lt;p&gt;We described earlier our resource as &lt;em&gt;an authentication session&lt;/em&gt;. Its actions were &lt;em&gt;to log in&lt;/em&gt; and &lt;em&gt;to log out&lt;/em&gt;. Simply translated to Python into a new mock:&lt;/p&gt;&lt;!--kg-card-begin: code--&gt;&lt;pre&gt;&lt;code class="language-python"&gt;from authenticated_datastore import AuthToken, AuthenticatedDatastore


class InMemoryAuthenticatedDatastore(InMemoryDatastore):

    _log = logging.getLogger('InMemoryAuthenticatedDatastore')
    credentials = 'foo:bar'

    @contextmanager
    def _session(self):
        session_token = self._login(self.credentials)
        try:
            yield
        finally:
            self._logout(session_token)

    @abstractmethod
    def _login(self, credentials) -&amp;gt; AuthToken:
        token = hash(credentials)
        self._log.debug('LOGIN: %s', token)
        return token

    @abstractmethod
    def _logout(self, token: AuthToken):
        self._log.debug('LOGOUT: %s', token)

    def push(self, content):
        with self._session():
            return super().push(content)

    def pull(self, identifier):
        with self._session():
            return super().push(content)&lt;/code&gt;&lt;/pre&gt;&lt;!--kg-card-end: code--&gt;&lt;p&gt;The session context manager is built so that once we are successfully logged in — when we enter the scope of the &lt;code&gt;with&lt;/code&gt; block — we will always log out &lt;em&gt;no matter what happens&lt;/em&gt;. Indeed, thanks to the generator-like approach in our context manager, we &lt;em&gt;yield&lt;/em&gt; within the scope of the &lt;code&gt;try&lt;/code&gt; block. We exit this block only when the yield returns — that is, when the &lt;code&gt;with&lt;/code&gt; scope is exited from the calling block.&lt;/p&gt;&lt;p&gt;Basically, that means that even if an exception is raised when we are within the scope of the session context manager, the session will be torn down before the exception ripples up:&lt;/p&gt;&lt;!--kg-card-begin: code--&gt;&lt;pre&gt;&lt;code class="language-python"&gt;&amp;gt;&amp;gt;&amp;gt; import logging
&amp;gt;&amp;gt;&amp;gt; logging.basicConfig(level=logging.DEBUG)
&amp;gt;&amp;gt;&amp;gt; from mock_datastore import InMemoryAuthenticatedDatastore as MockDatastore
&amp;gt;&amp;gt;&amp;gt; client = MockDatastore()
&amp;gt;&amp;gt;&amp;gt; i = client.push(b'an entry')
DEBUG:InMemoryAuthenticatedDatastore:LOGIN: 5444710130385190768
DEBUG:InMemoryAuthenticatedDatastore:PUSH: f0d4dc6b-38fa-485d-b96d-0ced4c10c382 with 8 bytes
DEBUG:InMemoryAuthenticatedDatastore:LOGOUT: 5444710130385190768
&amp;gt;&amp;gt;&amp;gt; c = client.pull(i)
DEBUG:InMemoryAuthenticatedDatastore:LOGIN: 5444710130385190768
DEBUG:InMemoryAuthenticatedDatastore:PULL: f0d4dc6b-38fa-485d-b96d-0ced4c10c382
DEBUG:InMemoryAuthenticatedDatastore:LOGOUT: 5444710130385190768
&amp;gt;&amp;gt;&amp;gt; print(c)
b'an entry
&amp;gt;&amp;gt;&amp;gt; client.pull(i)
DEBUG:InMemoryAuthenticatedDatastore:LOGIN: 5444710130385190768
DEBUG:InMemoryAuthenticatedDatastore:LOGOUT: 5444710130385190768
Traceback (most recent call last):
  ...
    raise KeyError(f"Unknown identifier {identifier!r}")
KeyError: "Unknown identifier 'f0d4dc6b-38fa-485d-b96d-0ced4c10c382'"
&lt;/code&gt;&lt;/pre&gt;&lt;!--kg-card-end: code--&gt;&lt;h2 id="performing-many-operations"&gt;Performing many operations&lt;/h2&gt;&lt;p&gt;As we just saw, each operation handles its own session scope. From an interface point of view, this is great, the datastore library is responsible for its own success and the library clients do not have to know about the session details. This also allows us to configure a datastore service (&lt;code&gt;Datastore&lt;/code&gt; and its children) at instantiation time and then forget about the service details. Perfect for dependency injection.&lt;/p&gt;&lt;p&gt;But calling many operations sequentially is far from ideal. Each operation will initiate a new session, perform its action, and then close the session. In our mono-threaded example, we are taking the network hit every single time we request a service operation.&lt;/p&gt;&lt;p&gt;Conversely, when a consumer wants to perform batch operations, it would be beneficial to open only one session, perform all operations, and only then close the session.&lt;/p&gt;&lt;p&gt;Let us see what trace we get if we try this with our current session context manager:&lt;/p&gt;&lt;!--kg-card-begin: code--&gt;&lt;pre&gt;&lt;code class="language-python"&gt;&amp;gt;&amp;gt;&amp;gt; from mock_datastore import InMemoryDatastore as MockDatastore
&amp;gt;&amp;gt;&amp;gt; client = MockDatastore()
&amp;gt;&amp;gt;&amp;gt; with client._session():
...     i = client.push('another entry')
...     client.pull(i)
... 
DEBUG:InMemoryAuthenticatedDatastore:LOGIN: 5444710130385190768
DEBUG:InMemoryAuthenticatedDatastore:LOGIN: 5444710130385190768
DEBUG:InMemoryAuthenticatedDatastore:PUSH: 3034f5e6-3ee8-42cb-b22e-48901afb1097 with 13 bytes
DEBUG:InMemoryAuthenticatedDatastore:LOGOUT: 5444710130385190768
DEBUG:InMemoryAuthenticatedDatastore:LOGIN: 5444710130385190768
DEBUG:InMemoryAuthenticatedDatastore:PULL: 3034f5e6-3ee8-42cb-b22e-48901afb1097
DEBUG:InMemoryAuthenticatedDatastore:LOGOUT: 5444710130385190768
'another entry'
DEBUG:InMemoryAuthenticatedDatastore:LOGOUT: 5444710130385190768&lt;/code&gt;&lt;/pre&gt;&lt;!--kg-card-end: code--&gt;&lt;p&gt;The current behaviour is clearly not what we want, we now even have one more session wrapping everything else!&lt;/p&gt;&lt;p&gt;In a lucky scenario, the remote service behaves nicely and re-use the existing session whenever we try to authenticate ourselves again. But unless this is an explicit service feature, we really should cater for this locally, in the library.&lt;/p&gt;&lt;h2 id="re-using-the-existing-session-or-the-reentrant-context-manager"&gt;Re-using the existing session, or the reentrant context manager&lt;/h2&gt;&lt;p&gt;The idea driving our use-case is that we keep a session open until it has served its purpose. We can only achieve this by &lt;em&gt;remembering&lt;/em&gt; that there is an open session already. And when a request for a session pops up, through a call to the session context manager, we can safely re-use the existing session instead of asking for a new one.&lt;/p&gt;&lt;p&gt;In computer science, this concept is famously applied to locks. A simple lock can be acquired once. Before any new acquiring, even by the current holder, the simple lock must be released. On the other hand, a reentrant lock can be acquired time and again by its current holder.&lt;/p&gt;&lt;p&gt;Our dummy in-memory datastore needs an update:&lt;/p&gt;&lt;!--kg-card-begin: code--&gt;&lt;pre&gt;&lt;code class="language-python"&gt;from typing import Optional


class InMemoryReentrantDatastore(InMemoryAuthenticatedDatastore):

    _log = logging.getLogger('InMemoryReentrantDatastore')
    _session_token: Optional[AuthToken] = None

    @contextmanager
    def _session(self):
        if self._session_token:
            yield
            return

        self._session_token = self._login(self.credentials)
        try:
            yield
        finally:
            self._logout(self._session_token)
&lt;/code&gt;&lt;/pre&gt;&lt;!--kg-card-end: code--&gt;&lt;p&gt;If a session token exists, it means that we are already within the scope of the session context manager. Thus we simply yield to allow the caller to complete, and then return from the context manager. The context manager that initiated the session token is the only one allowed to log out.&lt;/p&gt;&lt;!--kg-card-begin: code--&gt;&lt;pre&gt;&lt;code class="language-python"&gt;&amp;gt;&amp;gt;&amp;gt; from mock_datastore import InMemoryReentrantDatastore as MockDatastore
&amp;gt;&amp;gt;&amp;gt; client = MockDatastore()
&amp;gt;&amp;gt;&amp;gt; with client._session():
...     i = client.push('another entry')
...     client.pull(i)
...
DEBUG:InMemoryReentrantDatastore:LOGIN: -1271783380944662680
DEBUG:InMemoryReentrantDatastore:PUSH: db578045-674b-463f-9475-156315fcce29 with 13 bytes
DEBUG:InMemoryReentrantDatastore:PULL: db578045-674b-463f-9475-156315fcce29
'another entry'
DEBUG:InMemoryReentrantDatastore:LOGOUT: -1271783380944662680&lt;/code&gt;&lt;/pre&gt;&lt;!--kg-card-end: code--&gt;&lt;p&gt;The session scope is now respected: there is only one session created for the &lt;code&gt;InMemoryReentrantDatastore._session()&lt;/code&gt; context manager scope, no matter how many calls to methods requiring a session.&lt;/p&gt;&lt;p&gt;We should note that the current interface does not expose the session context manager as public to the library clients. Considering our contrived example, we can simply flatten the whole hierarchy and keep only one interface and one in-memory implementation. This is left as an exercise.&lt;/p&gt;&lt;h2 id="conclusion"&gt;Conclusion&lt;/h2&gt;&lt;p&gt;Python context managers are an easy way to abstract resource management in libraries. Their simple form flows and is enough as long as they remain independent. Upgrading a context manager to be reentrant is a simple and efficient way to allow a scope to be shared, without changing the context semantics.&lt;/p&gt;&lt;p&gt;&lt;a href="https://www.python.org/dev/peps/pep-0318/"&gt;Decorators&lt;/a&gt; are another powerful concept in Python. Our example uses the &lt;a href="https://docs.python.org/3/library/contextlib.html#contextlib.contextmanager"&gt;&lt;code&gt;contextlib.contextmanager&lt;/code&gt; decorator&lt;/a&gt; to wrap a function and make it into a context manager.&lt;/p&gt;&lt;p&gt;Would you like to use the session context manager as a decorator too? Go on, try it! Try both approaches and see which one reads and writes better &lt;em&gt;from the library client.&lt;/em&gt;&lt;/p&gt;</content:encoded></item></channel></rss></html>