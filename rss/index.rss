<!DOCTYPE html>
<html><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:media="http://search.yahoo.com/mrss/" version="2.0"><channel><title>Steady Monkey</title><description>Whatever thoughts out of Borjan's head.</description><link>http://localhost:3050/</link><image><url>http://localhost:3050/favicon.png</url><title>Steady Monkey</title><link>http://localhost:3050/</link></image><generator>Ghost 4.19</generator><lastBuildDate>Sun, 24 Oct 2021 20:33:14 GMT</lastBuildDate><atom:link href="http://localhost:3050/rss/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title>Upgrading my NAS to TrueNAS Core</title><description>&lt;p&gt;Over the course of the week-end, I (finally) upgraded from FreeNAS 11.3 to TrueNAS Core 12.0.&lt;/p&gt;&lt;p&gt;One of the most notable things with the new version is that it is strongly discouraged to use a USB stick as boot drive. Since my NAS has an internal USB port&lt;/p&gt;</description><link>http://localhost:3050/upgrading-my-nas-to-truenas-core/</link><guid isPermaLink="false">6175c0545908100001910bab</guid><category>Homelab</category><dc:creator>Borjan Tchakaloff</dc:creator><pubDate>Sun, 24 Oct 2021 19:23:26 GMT</pubDate><content:encoded>&lt;p&gt;Over the course of the week-end, I (finally) upgraded from FreeNAS 11.3 to TrueNAS Core 12.0.&lt;/p&gt;&lt;p&gt;One of the most notable things with the new version is that it is strongly discouraged to use a USB stick as boot drive. Since my NAS has an internal USB port for a boot stick, it is of course what I have been using since the beginning: a very small SanDisk Cruzer Fit of 16GB. Good opportunity to use that old (but unused) Intel SSD of 40GB that has been forgotten in the unnamed box of electronics.&lt;/p&gt;&lt;p&gt;My initial thought was to unplug everything from the motherboard, the data hard drives, the boot USB stick, the ethernet cable, and install TrueNAS on the SSD. Not only is that a bit on the paranoid side, it is also completely unnecessary. It turns out plugging in the SSD and adding it to the ZFS boot pool was enough to seamlessly upgrade my boot storage to a two-disk mirror. As a side-effect, my boot pool is limited by the smaller disk but I now have a &lt;em&gt;mirrored&lt;/em&gt; boot pool. Yay for redundancy. 16GB is enough for now anyway, the main disk space use is on OS upgrade to create a new boot environment. That does not happen so often to me (sic).&lt;/p&gt;&lt;p&gt;It is worth noting that the NAS do have a fifth SATA port, for the optional ODD (Optical Disk Drive). I decided to flash the BIOS with a well-known community mod to allow disabling the IDE mode on this fifth port, thus allowing the full SATA-3Gbps bandwidth.&lt;/p&gt;&lt;p&gt;If the USB stick comes to fail, I will still be able to boot the NAS from the SSD (which is the boot drive anyway). When that happens, I might get a USB-to-SATA adapter and fit another small SSD somewhere in the NAS enclosure to keep the mirrored boot pool.&lt;/p&gt;&lt;p&gt;Back to the upgrade: booting off a USB stick with TrueNAS Core 12.0 and selecting the &amp;quot;upgrade&amp;quot; process went as smooth as can be expected. And&amp;#x2026; that&amp;apos;s it, the NAS is up-to-date now. I am still impressed by how little maintenance is actually needed for FreeNAS/TrueNAS. Setting things up do take some time, though.&lt;/p&gt;</content:encoded></item><item><title>Refreshing my NAS configuration</title><description>&lt;p&gt;I setup my Network Attached Storage (NAS) back in 2014 after getting a nice discount on a HP MicroServer of the previous generation. I added some more ECC RAM, fitted four hard drives, installed FreeNAS, and then happily used it to offload my poor computers of all the media and&lt;/p&gt;</description><link>http://localhost:3050/refreshing-my-nas-configuration/</link><guid isPermaLink="false">6175c0545908100001910baa</guid><category>Homelab</category><dc:creator>Borjan Tchakaloff</dc:creator><pubDate>Sat, 28 Aug 2021 20:47:14 GMT</pubDate><content:encoded>&lt;p&gt;I setup my Network Attached Storage (NAS) back in 2014 after getting a nice discount on a HP MicroServer of the previous generation. I added some more ECC RAM, fitted four hard drives, installed FreeNAS, and then happily used it to offload my poor computers of all the media and random stuff I had lying around there. When I moved out of the country in 2015, I packed light and left the NAS behind. Until 2021.&lt;/p&gt;&lt;p&gt;The 2TB hard drives are not so big by today&amp;apos;s standards but I am happy with the 3.4TB total storage space for now (the hard drives are setup in a RAID-Z2 array, allowing me to lose two drives out of four). Of course if I lose a drive, chances are the others will fail soon too. Maybe even during the resilvering (rebuilding the RAID after replacing the faulty drive). &lt;em&gt;A RAID array is not a backup.&lt;/em&gt; I read multiple times that 6 drives would give the best trade-off with RAID-Z2, but unless I fit two more 3.5&amp;quot; hard drives in that small space (it&amp;apos;s not hot in there, but the fans and drives are too loud already), it&amp;apos;s not going to happen any time soon.&lt;/p&gt;&lt;p&gt;I did a few routine maintenance updates of FreeNAS itself, but I am still lagging behind on an unsupported version. The latest version is not even called FreeNAS anymore, it&amp;apos;s &lt;a href="https://www.truenas.com/truenas-core/"&gt;TrueNAS CORE&lt;/a&gt; now. Though I have to say that after the initial setup, I simply forgot about it and simply used the NFS shares for a bit. It just worked.&lt;/p&gt;&lt;p&gt;When I configured FreeNAS in 2014, I had no idea about how many datasets I should create and how I should split my data. I simply went with &lt;em&gt;documents&lt;/em&gt; (to store my home dirs), &lt;em&gt;media&lt;/em&gt; (music, movies, and the like), and &lt;em&gt;raw&lt;/em&gt; (everything else that was not nicely sorted such as mirrors of external drives and copies of old (internal) drives before disposing of the hosts).&lt;/p&gt;&lt;p&gt;I won&amp;apos;t lie, I am still a neophyte when it comes to handling FreeBSD (e.g. the jails) and configuring it. Last week I managed to mess up all file permissions of one of my datasets. Thankfully it was my home dirs mirror, so it does not matter if I blindly reset the permissions to &lt;code&gt;u+rwX,go=&lt;/code&gt;. I also realised that I was naive enough to store my NAS user account on that same dataset. So when I reset the permissions, I also set the wrong bits for the SSH configuration and could not login anymore. It took me a shamefully long time to realise why I could not remotely log-in. I finally solved my problem with the help of the console in the FreeNAS UI: one call to &lt;code&gt;chmod&lt;/code&gt; later and I could log-in again.&lt;/p&gt;&lt;p&gt;Here is the new scheme I came up with:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;home&lt;/code&gt;: simply the home directories of the NAS accounts; I don&amp;apos;t want to stupidly break my SSH configuration anymore&lt;/li&gt;&lt;li&gt;&lt;code&gt;dione&lt;/code&gt;, &lt;code&gt;iapetus&lt;/code&gt;, &amp;#x2026;: mirrors of the data stored on my everyday computers&lt;/li&gt;&lt;li&gt;&lt;code&gt;media&lt;/code&gt;: original dataset for multimedia files &amp;#x2013; still a good idea&lt;/li&gt;&lt;li&gt;&lt;code&gt;raw&lt;/code&gt;: original staging dataset of files I am supposed to review and categorise &amp;#x2013; only relevant if I &lt;em&gt;actually&lt;/em&gt; move things out of it, otherwise I should rename it to &lt;code&gt;dumpster&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;The idea of mirroring data from my computers is that I can leverage ZFS snapshots directly on the NAS and not handle a more-or-less complicated, and more-or-less very slow incremental local backup process. I do not work with really big files on my computers. The only time I access big multimedia files is when I travel and I want a local cache of movies/series. I am fine &lt;code&gt;rsync&lt;/code&gt;-ing a subset of my filesystem over the wire to the NAS every day.&lt;/p&gt;&lt;p&gt;I thought that it would be really nice to be able to browse through the snapshots in a user-friendly manner, for instance if I want to restore an older version of a file. After a few days of leaving that train of thoughts on the back-burner, I came to the conclusion that I actually do not need that feature. I don&amp;apos;t care about selective restoration. I don&amp;apos;t need a time machine for individual files because if I do, then I use a version control system (e.g. Git). I imagine that the only times I would need to restore a snapshot are if I have a hardware failure, and if my files end up encrypted by some external entity asking me to pay them in cryptocurrency in exchange for the decryption key. In both cases I can take the time to navigate through manually cloning the snapshots in question and promoting it or restoring from it.&lt;/p&gt;&lt;p&gt;Next up: switching from &lt;code&gt;D&amp;#xE9;j&amp;#xE0;Dup&lt;/code&gt; against Google Drive to &lt;code&gt;rsync&lt;/code&gt; to the NAS.&lt;/p&gt;</content:encoded></item><item><title>A reentrant context manager in Python</title><description>A Python context manager caters for the boilerplate wrapping a resource to offer safety and convenient (re-)use. Upgrading a context manager to be reentrant is a simple and efficient way to allow a scope to be shared, without changing the context semantics.</description><link>http://localhost:3050/a-reentrant-context-manager-in-python/</link><guid isPermaLink="false">6175c0545908100001910ba8</guid><category>Python</category><dc:creator>Borjan Tchakaloff</dc:creator><pubDate>Sun, 05 Jan 2020 18:43:10 GMT</pubDate><content:encoded>&lt;p&gt;A Python context manager caters for the boilerplate wrapping a resource to offer safety and convenient (re-)use. This protocol ensures that once the context is initialised, it will be torn down whatever happens. Examples of resource handling are input/output operations, session management, thread locking, etc. In this article, we will take a focus peek at one &amp;quot;&lt;a href="https://www.python.org/dev/peps/pep-0020/#the-zen-of-python"&gt;honking great idea&lt;/a&gt;&amp;quot;: a &lt;strong&gt;reentrant context manager&lt;/strong&gt;.&lt;/p&gt;&lt;p&gt;There has been &lt;a href="http://johnj.com/intro-to-context-managers-in-python.html"&gt;many&lt;/a&gt; &lt;a href="https://book.pythontips.com/en/latest/context_managers.html"&gt;articles&lt;/a&gt; and pages of &lt;a href="https://en.wikibooks.org/wiki/Python_Programming/Context_Managers"&gt;documentation&lt;/a&gt; to explain why context managers are a good thing, and why you would want to &lt;a href="https://jeffknupp.com/blog/2016/03/07/python-with-context-managers/"&gt;always&lt;em&gt; &lt;/em&gt;handle your resources&lt;/a&gt; with them.&lt;/p&gt;&lt;p&gt;Drawing from classic computer science principles, we propose here to extend the &lt;em&gt;context manager&lt;/em&gt; with the &lt;em&gt;reentrant&lt;/em&gt; principle to achieve a simple, yet powerful, resource management.&lt;/p&gt;&lt;h2 id="our-case-study-a-data-store"&gt;Our case study: a data store&lt;/h2&gt;&lt;p&gt;Suppose you are writing a library for a (remote) service. It could be that you want to offer a nice Python interface for your own service, or simply that you want to abstract the service itself from your business code &amp;#x2014; a &lt;a href="https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html"&gt;sound idea&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;Our example service is a data store. A user can push, and then pull, arbitrary data from it. Any data that is stored there is associated to a unique identifier. Later, and at one&amp;apos;s request, the identifier can be used to pull the data out of the store once and for all. The store will forget about that piece of data.&lt;/p&gt;&lt;pre&gt;&lt;code class="language-python"&gt;# datastore.py
from abc import ABC, abstractmethod


Content = bytes
Identifier = str


class Datastore(ABC):

    @abstractmethod
    def push(self, content: Content) -&amp;gt; Identifier:
        ...

    @abstractmethod
    def pull(self, identifier: Identifier) -&amp;gt; Content:
        ...
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The interface is simple and clean. &lt;code&gt;Datastore&lt;/code&gt; is an &lt;a href="https://docs.python.org/3/glossary.html#term-abstract-base-class"&gt;abstract class&lt;/a&gt; with two public (abstract) methods.&lt;/p&gt;&lt;p&gt;Let&amp;apos;s create an in-memory datastore to mock the service and trace the interface calls:&lt;/p&gt;&lt;pre&gt;&lt;code class="language-python"&gt;# mock_datastore.py
import logging
from uuid import uuid4

from datastore import Content, Datastore, Identifier


class InMemoryDatastore(Datastore):

    _log = logging.getLogger(&amp;apos;InMemoryDatastore&amp;apos;)
    _store = []

    def push(self, content):
        identifier = str(uuid4())
        self._log.debug(&amp;apos;PUSH: %s with %s bytes&amp;apos;, identifier, len(content))
        self._store[identifier] = content
        return identifier

    def pull(self, identifier):
        if identifier not in self._store:
            raise KeyError(f&amp;quot;Unknown identifier {identifier!r}&amp;quot;)
        self._log.debug(f&amp;apos;PULL: %s&amp;apos;, identifier)
        content = self._store.pop(identifier)
        return content
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We can now store and retrieve content from a datastore:&lt;/p&gt;&lt;pre&gt;&lt;code class="language-python"&gt;&amp;gt;&amp;gt;&amp;gt; import logging
&amp;gt;&amp;gt;&amp;gt; logging.basicConfig(level=logging.DEBUG)
&amp;gt;&amp;gt;&amp;gt; from mock_datastore import InMemoryDatastore as MockDatastore
&amp;gt;&amp;gt;&amp;gt; client = MockDatastore()
&amp;gt;&amp;gt;&amp;gt; i = client.push(b&amp;apos;an entry&amp;apos;)
DEBUG:InMemoryDatastore:PUSH: 53d387c9-8d96-4ca8-a1c5-f6d5efffc572 with 8 bytes
&amp;gt;&amp;gt;&amp;gt; client.pull(i)
DEBUG:InMemoryDatastore:PULL: 53d387c9-8d96-4ca8-a1c5-f6d5efffc572
b&amp;apos;an entry&amp;apos;
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id="-for-authenticated-users"&gt;&amp;#x2026; for authenticated users&lt;/h2&gt;&lt;p&gt;Say there is a new requirement: all actions undertook against the data store must be authenticated. The client interface should handle this and provide a construct to deal with &lt;em&gt;sessions&lt;/em&gt;. There is no need for the interface consumer to have to manually log in and out, we will not change the &lt;code&gt;Datastore&lt;/code&gt; interface. The library we are writing is supposed to &lt;em&gt;help&lt;/em&gt; the consumer, not clutter its interface.&lt;/p&gt;&lt;p&gt;We will define the authentication methods as &amp;quot;private/protected&amp;quot; and use them to push and pull data to the data store, from the implementation classes themselves. To avoid repeating ourselves, we simply define a new interface:&lt;/p&gt;&lt;pre&gt;&lt;code class="language-python"&gt;# authenticated_datastore.py

from abc import abstractmethod
from contextlib import contextmanager

from datastore import Datastore


AuthToken = str


class AuthenticatedDatastore(Datastore):

    @abstractmethod
    def push(self, content):
        ...

    @abstractmethod
    def pull(self, identifier):
        ...

    @abstractmethod
    def _login(self, credentials) -&amp;gt; AuthToken:
        ...

    @abstractmethod
    def _logout(self, token: AuthToken):
        ...
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Good programmers are lazy, they say. Programmers always want to make things silly simple and efficient. I could not agree more, especially if there is an exposed interface at play.&lt;/p&gt;&lt;p&gt;The implementation classes have to remember to call &lt;code&gt;_logout()&lt;/code&gt; every time they call &lt;code&gt;_login()&lt;/code&gt;. What happens to us when we burden ourselves with hand-woven resource management? Things break, memory leaks, and we become sad.&lt;/p&gt;&lt;p&gt;The authentication as we just defined it &lt;strong&gt;is a resource&lt;/strong&gt; that we manage: we have to create (&lt;em&gt;to log in&lt;/em&gt;) and destroy (&lt;em&gt;to log out&lt;/em&gt;) each instance we handle (&lt;em&gt;a session&lt;/em&gt;). Let&amp;apos;s take a look at a nifty solution Python offers us: the context manager.&lt;/p&gt;&lt;h2 id="what-a-context-manager-is-by-example"&gt;What a context manager is, by example&lt;/h2&gt;&lt;p&gt;The Python documentation describes &lt;a href="https://docs.python.org/3/reference/datamodel.html#context-managers"&gt;a context manager&lt;/a&gt; as:&lt;/p&gt;&lt;blockquote&gt;[&amp;#x2026;] an object that defines the runtime context to be established when executing a &lt;code&gt;with&lt;/code&gt; statement. The context manager handles the entry into, and the exit from, the desired runtime context for the execution of the block of code.&lt;/blockquote&gt;&lt;p&gt;Said differently, the scope of a context manager is tied to an object life-cycle. But instead of the regular &lt;em&gt;initialisation&lt;/em&gt; and &lt;em&gt;destruction&lt;/em&gt; of the object, a different protocol is used (aptly named&amp;#x2026; &lt;a href="https://docs.python.org/3/library/stdtypes.html#typecontextmanager"&gt;Context Manager&lt;/a&gt;). It defines the interface for &lt;em&gt;entry&lt;/em&gt; and &lt;em&gt;exit&lt;/em&gt; of the scope.&lt;/p&gt;&lt;p&gt;We described earlier our resource as &lt;em&gt;an authentication session&lt;/em&gt;. Its actions were &lt;em&gt;to log in&lt;/em&gt; and &lt;em&gt;to log out&lt;/em&gt;. Simply translated to Python into a new mock:&lt;/p&gt;&lt;pre&gt;&lt;code class="language-python"&gt;from authenticated_datastore import AuthToken, AuthenticatedDatastore


class InMemoryAuthenticatedDatastore(InMemoryDatastore):

    _log = logging.getLogger(&amp;apos;InMemoryAuthenticatedDatastore&amp;apos;)
    credentials = &amp;apos;foo:bar&amp;apos;

    @contextmanager
    def _session(self):
        session_token = self._login(self.credentials)
        try:
            yield
        finally:
            self._logout(session_token)

    @abstractmethod
    def _login(self, credentials) -&amp;gt; AuthToken:
        token = hash(credentials)
        self._log.debug(&amp;apos;LOGIN: %s&amp;apos;, token)
        return token

    @abstractmethod
    def _logout(self, token: AuthToken):
        self._log.debug(&amp;apos;LOGOUT: %s&amp;apos;, token)

    def push(self, content):
        with self._session():
            return super().push(content)

    def pull(self, identifier):
        with self._session():
            return super().push(content)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The session context manager is built so that once we are successfully logged in &amp;#x2014; when we enter the scope of the &lt;code&gt;with&lt;/code&gt; block &amp;#x2014; we will always log out &lt;em&gt;no matter what happens&lt;/em&gt;. Indeed, thanks to the generator-like approach in our context manager, we &lt;em&gt;yield&lt;/em&gt; within the scope of the &lt;code&gt;try&lt;/code&gt; block. We exit this block only when the yield returns &amp;#x2014; that is, when the &lt;code&gt;with&lt;/code&gt; scope is exited from the calling block.&lt;/p&gt;&lt;p&gt;Basically, that means that even if an exception is raised when we are within the scope of the session context manager, the session will be torn down before the exception ripples up:&lt;/p&gt;&lt;pre&gt;&lt;code class="language-python"&gt;&amp;gt;&amp;gt;&amp;gt; import logging
&amp;gt;&amp;gt;&amp;gt; logging.basicConfig(level=logging.DEBUG)
&amp;gt;&amp;gt;&amp;gt; from mock_datastore import InMemoryAuthenticatedDatastore as MockDatastore
&amp;gt;&amp;gt;&amp;gt; client = MockDatastore()
&amp;gt;&amp;gt;&amp;gt; i = client.push(b&amp;apos;an entry&amp;apos;)
DEBUG:InMemoryAuthenticatedDatastore:LOGIN: 5444710130385190768
DEBUG:InMemoryAuthenticatedDatastore:PUSH: f0d4dc6b-38fa-485d-b96d-0ced4c10c382 with 8 bytes
DEBUG:InMemoryAuthenticatedDatastore:LOGOUT: 5444710130385190768
&amp;gt;&amp;gt;&amp;gt; c = client.pull(i)
DEBUG:InMemoryAuthenticatedDatastore:LOGIN: 5444710130385190768
DEBUG:InMemoryAuthenticatedDatastore:PULL: f0d4dc6b-38fa-485d-b96d-0ced4c10c382
DEBUG:InMemoryAuthenticatedDatastore:LOGOUT: 5444710130385190768
&amp;gt;&amp;gt;&amp;gt; print(c)
b&amp;apos;an entry
&amp;gt;&amp;gt;&amp;gt; client.pull(i)
DEBUG:InMemoryAuthenticatedDatastore:LOGIN: 5444710130385190768
DEBUG:InMemoryAuthenticatedDatastore:LOGOUT: 5444710130385190768
Traceback (most recent call last):
  ...
    raise KeyError(f&amp;quot;Unknown identifier {identifier!r}&amp;quot;)
KeyError: &amp;quot;Unknown identifier &amp;apos;f0d4dc6b-38fa-485d-b96d-0ced4c10c382&amp;apos;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id="performing-many-operations"&gt;Performing many operations&lt;/h2&gt;&lt;p&gt;As we just saw, each operation handles its own session scope. From an interface point of view, this is great, the datastore library is responsible for its own success and the library clients do not have to know about the session details. This also allows us to configure a datastore service (&lt;code&gt;Datastore&lt;/code&gt; and its children) at instantiation time and then forget about the service details. Perfect for dependency injection.&lt;/p&gt;&lt;p&gt;But calling many operations sequentially is far from ideal. Each operation will initiate a new session, perform its action, and then close the session. In our mono-threaded example, we are taking the network hit every single time we request a service operation.&lt;/p&gt;&lt;p&gt;Conversely, when a consumer wants to perform batch operations, it would be beneficial to open only one session, perform all operations, and only then close the session.&lt;/p&gt;&lt;p&gt;Let us see what trace we get if we try this with our current session context manager:&lt;/p&gt;&lt;pre&gt;&lt;code class="language-python"&gt;&amp;gt;&amp;gt;&amp;gt; from mock_datastore import InMemoryDatastore as MockDatastore
&amp;gt;&amp;gt;&amp;gt; client = MockDatastore()
&amp;gt;&amp;gt;&amp;gt; with client._session():
...     i = client.push(&amp;apos;another entry&amp;apos;)
...     client.pull(i)
... 
DEBUG:InMemoryAuthenticatedDatastore:LOGIN: 5444710130385190768
DEBUG:InMemoryAuthenticatedDatastore:LOGIN: 5444710130385190768
DEBUG:InMemoryAuthenticatedDatastore:PUSH: 3034f5e6-3ee8-42cb-b22e-48901afb1097 with 13 bytes
DEBUG:InMemoryAuthenticatedDatastore:LOGOUT: 5444710130385190768
DEBUG:InMemoryAuthenticatedDatastore:LOGIN: 5444710130385190768
DEBUG:InMemoryAuthenticatedDatastore:PULL: 3034f5e6-3ee8-42cb-b22e-48901afb1097
DEBUG:InMemoryAuthenticatedDatastore:LOGOUT: 5444710130385190768
&amp;apos;another entry&amp;apos;
DEBUG:InMemoryAuthenticatedDatastore:LOGOUT: 5444710130385190768&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The current behaviour is clearly not what we want, we now even have one more session wrapping everything else!&lt;/p&gt;&lt;p&gt;In a lucky scenario, the remote service behaves nicely and re-use the existing session whenever we try to authenticate ourselves again. But unless this is an explicit service feature, we really should cater for this locally, in the library.&lt;/p&gt;&lt;h2 id="re-using-the-existing-session-or-the-reentrant-context-manager"&gt;Re-using the existing session, or the reentrant context manager&lt;/h2&gt;&lt;p&gt;The idea driving our use-case is that we keep a session open until it has served its purpose. We can only achieve this by &lt;em&gt;remembering&lt;/em&gt; that there is an open session already. And when a request for a session pops up, through a call to the session context manager, we can safely re-use the existing session instead of asking for a new one.&lt;/p&gt;&lt;p&gt;In computer science, this concept is famously applied to locks. A simple lock can be acquired once. Before any new acquiring, even by the current holder, the simple lock must be released. On the other hand, a reentrant lock can be acquired time and again by its current holder.&lt;/p&gt;&lt;p&gt;Our dummy in-memory datastore needs an update:&lt;/p&gt;&lt;pre&gt;&lt;code class="language-python"&gt;from typing import Optional


class InMemoryReentrantDatastore(InMemoryAuthenticatedDatastore):

    _log = logging.getLogger(&amp;apos;InMemoryReentrantDatastore&amp;apos;)
    _session_token: Optional[AuthToken] = None

    @contextmanager
    def _session(self):
        if self._session_token:
            yield
            return

        self._session_token = self._login(self.credentials)
        try:
            yield
        finally:
            self._logout(self._session_token)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;If a session token exists, it means that we are already within the scope of the session context manager. Thus we simply yield to allow the caller to complete, and then return from the context manager. The context manager that initiated the session token is the only one allowed to log out.&lt;/p&gt;&lt;pre&gt;&lt;code class="language-python"&gt;&amp;gt;&amp;gt;&amp;gt; from mock_datastore import InMemoryReentrantDatastore as MockDatastore
&amp;gt;&amp;gt;&amp;gt; client = MockDatastore()
&amp;gt;&amp;gt;&amp;gt; with client._session():
...     i = client.push(&amp;apos;another entry&amp;apos;)
...     client.pull(i)
...
DEBUG:InMemoryReentrantDatastore:LOGIN: -1271783380944662680
DEBUG:InMemoryReentrantDatastore:PUSH: db578045-674b-463f-9475-156315fcce29 with 13 bytes
DEBUG:InMemoryReentrantDatastore:PULL: db578045-674b-463f-9475-156315fcce29
&amp;apos;another entry&amp;apos;
DEBUG:InMemoryReentrantDatastore:LOGOUT: -1271783380944662680&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The session scope is now respected: there is only one session created for the &lt;code&gt;InMemoryReentrantDatastore._session()&lt;/code&gt; context manager scope, no matter how many calls to methods requiring a session.&lt;/p&gt;&lt;p&gt;We should note that the current interface does not expose the session context manager as public to the library clients. Considering our contrived example, we can simply flatten the whole hierarchy and keep only one interface and one in-memory implementation. This is left as an exercise.&lt;/p&gt;&lt;h2 id="conclusion"&gt;Conclusion&lt;/h2&gt;&lt;p&gt;Python context managers are an easy way to abstract resource management in libraries. Their simple form flows and is enough as long as they remain independent. Upgrading a context manager to be reentrant is a simple and efficient way to allow a scope to be shared, without changing the context semantics.&lt;/p&gt;&lt;p&gt;&lt;a href="https://www.python.org/dev/peps/pep-0318/"&gt;Decorators&lt;/a&gt; are another powerful concept in Python. Our example uses the &lt;a href="https://docs.python.org/3/library/contextlib.html#contextlib.contextmanager"&gt;&lt;code&gt;contextlib.contextmanager&lt;/code&gt; decorator&lt;/a&gt; to wrap a function and make it into a context manager.&lt;/p&gt;&lt;p&gt;Would you like to use the session context manager as a decorator too? Go on, try it! Try both approaches and see which one reads and writes better &lt;em&gt;from the library client.&lt;/em&gt;&lt;/p&gt;</content:encoded></item><item><title>(Untitled)</title><description>&lt;p&gt;Ah! The joy of looking at a clean slate. Scary. Wondrous.&lt;/p&gt;&lt;p&gt;A clean and uncluttered editor helps focus on what matters: the prose. I might come to like this. Surrendering to the thoughts that come to life while keyed on the computer. It is a form of meditation.&lt;/p&gt;&lt;p&gt;Enough for&lt;/p&gt;</description><link>http://localhost:3050/untitled/</link><guid isPermaLink="false">6175c0545908100001910ba7</guid><category>Thoughts</category><dc:creator>Borjan Tchakaloff</dc:creator><pubDate>Sun, 01 Dec 2019 17:21:44 GMT</pubDate><content:encoded>&lt;p&gt;Ah! The joy of looking at a clean slate. Scary. Wondrous.&lt;/p&gt;&lt;p&gt;A clean and uncluttered editor helps focus on what matters: the prose. I might come to like this. Surrendering to the thoughts that come to life while keyed on the computer. It is a form of meditation.&lt;/p&gt;&lt;p&gt;Enough for now, I have to figure out if this interface can appear in French too. Not that it matters so much for what I want to do. Who knows, I might want to advocate for this platform to non tech-savvy people.&lt;/p&gt;&lt;hr&gt;&lt;p&gt;No, really. This editor is the best I&amp;apos;ve tried so far. Oh, I can even drag-n-drop blocks. Neat &amp;#x263A;!&lt;/p&gt;&lt;hr&gt;&lt;p&gt;It is a shame the interface is not translated. I suppose I&amp;apos;ll just have to take the role of editor as well as publisher.&lt;/p&gt;</content:encoded></item></channel></rss></html>