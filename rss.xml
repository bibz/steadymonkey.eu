<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0" xmlns:media="http://search.yahoo.com/mrss/"><channel><title><![CDATA[Steady Monkey]]></title><description><![CDATA[Whatever thoughts out of Borjan's head.]]></description><link>https://steadymonkey.eu/</link><image><url>https://steadymonkey.eu/favicon.png</url><title>Steady Monkey</title><link>https://steadymonkey.eu/</link></image><generator>Ghost 4.19</generator><lastBuildDate>Sun, 05 Jun 2022 13:09:24 GMT</lastBuildDate><atom:link href="https://steadymonkey.eu/rss.xml" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title><![CDATA[Exploring Mainboard housing v1 with cardboard]]></title><description><![CDATA[<p>Yesterday I played around with cardboard to have a better (physical) sense of the first housing version. In short, this housing will be the simplest I can build to fit the Mainboard and an Atreus keyboard. Nothing fancy, not even an internal routing of the USB cable. In the end</p>]]></description><link>https://steadymonkey.eu/exploring-mainboard-housing-v1-with-cardboard/</link><guid isPermaLink="false">629c9f87103b1a0001223917</guid><category><![CDATA[Mainboard]]></category><dc:creator><![CDATA[Borjan Tchakaloff]]></dc:creator><pubDate>Sun, 05 Jun 2022 13:02:14 GMT</pubDate><content:encoded><![CDATA[<p>Yesterday I played around with cardboard to have a better (physical) sense of the first housing version. In short, this housing will be the simplest I can build to fit the Mainboard and an Atreus keyboard. Nothing fancy, not even an internal routing of the USB cable. In the end I want to build momentum and, considering the blocks of time I can allocate to this project, I figured it would be best to use (very) small increments.</p><p>Laying out the Mainboard and the Atreus side-to-side on a piece of cardboard (cut to be as wide as the Atreus case is) really shows how similarly sized the two elements are. Let&apos;s cut another template for the Atreus&apos; PCB layer (the layer, either PCB or plywood, that holds the key switches) and fit them together.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://steadymonkey.eu/content/images/2022/06/laying-out-mainboard-and-atreus.jpeg" class="kg-image" alt loading="lazy" width="1200" height="900" srcset="https://steadymonkey.eu/content/images/size/w600/2022/06/laying-out-mainboard-and-atreus.jpeg 600w, https://steadymonkey.eu/content/images/size/w1000/2022/06/laying-out-mainboard-and-atreus.jpeg 1000w, https://steadymonkey.eu/content/images/2022/06/laying-out-mainboard-and-atreus.jpeg 1200w" sizes="(min-width: 720px) 720px"><figcaption>Laying out the Mainboard and the Atreus on a piece of cardboard. (The cardboard is as wide as the Atreus case is.)</figcaption></figure><p>I came up with two possible designs to optimally fit the Mainboard (roughly 232&#xD7;104mm) and the PCB layer of the Atreus (roughly 226&#xD7;90mm in its rectangular form, otherwise the shorter side is down to 72mm). The first one (bottom in the following picture) is simply placing the keyboard on top of the mainboard, aligning them at the bottom. This really is the minimum form factor I can come up with right now (that is, without using a sturdier housing material to make the walls thinner). The second option is to keep the Atreus split angles and letting it slip past the Mainboard bottom side.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://steadymonkey.eu/content/images/2022/06/optimally-fitting-both-mainboard-and-atreus-pcb.jpeg" class="kg-image" alt loading="lazy" width="1200" height="900" srcset="https://steadymonkey.eu/content/images/size/w600/2022/06/optimally-fitting-both-mainboard-and-atreus-pcb.jpeg 600w, https://steadymonkey.eu/content/images/size/w1000/2022/06/optimally-fitting-both-mainboard-and-atreus-pcb.jpeg 1000w, https://steadymonkey.eu/content/images/2022/06/optimally-fitting-both-mainboard-and-atreus-pcb.jpeg 1200w" sizes="(min-width: 720px) 720px"><figcaption>Optimally fitting the Mainboard (in green) and the Atreus PCB (in red), keeping 15mm of surrounding walls (in yellow).</figcaption></figure><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://steadymonkey.eu/content/images/2022/06/on-top-of-each-other.jpeg" class="kg-image" alt loading="lazy" width="1200" height="900" srcset="https://steadymonkey.eu/content/images/size/w600/2022/06/on-top-of-each-other.jpeg 600w, https://steadymonkey.eu/content/images/size/w1000/2022/06/on-top-of-each-other.jpeg 1000w, https://steadymonkey.eu/content/images/2022/06/on-top-of-each-other.jpeg 1200w" sizes="(min-width: 720px) 720px"><figcaption>The two designs on top of each other. Only the bottom side differs.</figcaption></figure><p>Obviously the second is design is preferred because otherwise there would be a lot of &quot;blank&quot; housing on the left and right most side of the keyboard, denying the advantage the split angles the Atreus offers. The first design would be relevant for a plain (ortholinear) matrix-style keyboard. But I am fine making the housing slightly larger to keep the split angles.</p><p>To illustrate the size taken by the Atreus PCB layer, see the following picture. It would be the shape that encloses all key switches.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://steadymonkey.eu/content/images/2022/06/carboard-and-pcb-layer.jpeg" class="kg-image" alt loading="lazy" width="1200" height="900" srcset="https://steadymonkey.eu/content/images/size/w600/2022/06/carboard-and-pcb-layer.jpeg 600w, https://steadymonkey.eu/content/images/size/w1000/2022/06/carboard-and-pcb-layer.jpeg 1000w, https://steadymonkey.eu/content/images/2022/06/carboard-and-pcb-layer.jpeg 1200w" sizes="(min-width: 720px) 720px"><figcaption>The Atreus PCB layer vs. the cardboard pattern. I only consider the area needed for the key switches, not the space around them.</figcaption></figure><p>As can be seen on the following two pictures, the housing design is very close to the original Atreus footprint; I actually used the width of the Atreus as a guide here. The major difference is that the thickness will be approximately doubled.</p><figure class="kg-card kg-gallery-card kg-width-wide kg-card-hascaption"><div class="kg-gallery-container"><div class="kg-gallery-row"><div class="kg-gallery-image"><img src="https://steadymonkey.eu/content/images/2022/06/atreus-above-cardboard.jpeg" width="1200" height="900" loading="lazy" alt srcset="https://steadymonkey.eu/content/images/size/w600/2022/06/atreus-above-cardboard.jpeg 600w, https://steadymonkey.eu/content/images/size/w1000/2022/06/atreus-above-cardboard.jpeg 1000w, https://steadymonkey.eu/content/images/2022/06/atreus-above-cardboard.jpeg 1200w" sizes="(min-width: 720px) 720px"></div><div class="kg-gallery-image"><img src="https://steadymonkey.eu/content/images/2022/06/atreus-above-cardboard-corner-zoom.jpeg" width="1200" height="900" loading="lazy" alt srcset="https://steadymonkey.eu/content/images/size/w600/2022/06/atreus-above-cardboard-corner-zoom.jpeg 600w, https://steadymonkey.eu/content/images/size/w1000/2022/06/atreus-above-cardboard-corner-zoom.jpeg 1000w, https://steadymonkey.eu/content/images/2022/06/atreus-above-cardboard-corner-zoom.jpeg 1200w" sizes="(min-width: 720px) 720px"></div></div></div><figcaption>The Atreus on top of the cardboard design, they have the same width.</figcaption></figure>]]></content:encoded></item><item><title><![CDATA[The transportable Mainboard-based computer]]></title><description><![CDATA[<p>As I previously mentioned, my goal for the Framework Mainboard I will receive as part of the Mainboard Developer Program is twofold: build 1) a transportable computer that has 2) a better keyboard. The challenge is mainly about my own lack of experience as a maker. And that I don&</p>]]></description><link>https://steadymonkey.eu/the-transportable-mainboard-based-computer/</link><guid isPermaLink="false">6288f072103b1a0001223840</guid><category><![CDATA[Mainboard]]></category><dc:creator><![CDATA[Borjan Tchakaloff]]></dc:creator><pubDate>Sun, 29 May 2022 15:17:00 GMT</pubDate><content:encoded><![CDATA[<p>As I previously mentioned, my goal for the Framework Mainboard I will receive as part of the Mainboard Developer Program is twofold: build 1) a transportable computer that has 2) a better keyboard. The challenge is mainly about my own lack of experience as a maker. And that I don&apos;t want to use highly specialised equipment such as CNC machining or 3D printing, at least not for the first iterations.</p><p>To support my low-key approach, I plan on using thin plywood sheets cheaply sold in craft- or home improvement stores. In my European neighbourhood I can get four A3 sheets of 4mm poplar plywood for about &#x20AC;6. Then some paper, glue, and a printer to lay out the patterns; a wood knife, a coping saw, and some sand paper to model the plywood. That should do the trick. (Watch this blog to see what I end up doing when 90% of my assumptions prove wrong.)</p><p>I literally advertised my project as &quot;combin[ing] a mainboard with an <a href="https://atreus.technomancy.us">Atreus keyboard</a>. Not unlike computers of old. At home: USB-C dock, on the go: USB-C external monitor.&quot; Which means I need access to at least two USB-C ports, so that I can still plug a gadget on the go when the first USB-C port is handling power and display. (I know, I could also unplug the dock and bring it on the go. But <em>really</em>, who wants to have a single USB port on their machine?)</p><p>Keeping that in mind, the first viable iteration needs to fulfill the following criteriae:</p><ol><li>Standalone housing for the Mainboard and a mechanical keyboard on top.</li><li>At least two USB-C ports accessible externally. <em>Externally</em> in case the housing is large enough to encompass internal USB-C connections.</li><li>The upper face &#x2014;holding the keyboard&#x2014; should be modular. I want to be able to change it to e.g. allow for an alternative layout like QWERTY. That is the piece I think has the most chance to change over time. Because I might want to change the keyboard (I am very intrigued by <a href="https://github.com/manna-harbour/miryoku">Miryoku</a> which is quite close to Atreus).</li></ol>]]></content:encoded></item><item><title><![CDATA[I got in the Framework Mainboard Developer Program]]></title><description><![CDATA[<p>Two weeks ago, I received an e-mail telling me I had been accepted in <em>the Framework Mainboard Developer Program</em>. <a href="https://frame.work/">Framework</a> has a very interesting approach to sustainability in electronics that reminds me of Fairphone, though I don&apos;t want to compare them directly. I worked at Fairphone for more</p>]]></description><link>https://steadymonkey.eu/i-got-in-the-framework-mainboard-developer-program/</link><guid isPermaLink="false">6288e40e103b1a000122374b</guid><category><![CDATA[Thoughts]]></category><category><![CDATA[Mainboard]]></category><dc:creator><![CDATA[Borjan Tchakaloff]]></dc:creator><pubDate>Sat, 21 May 2022 13:58:09 GMT</pubDate><content:encoded><![CDATA[<p>Two weeks ago, I received an e-mail telling me I had been accepted in <em>the Framework Mainboard Developer Program</em>. <a href="https://frame.work/">Framework</a> has a very interesting approach to sustainability in electronics that reminds me of Fairphone, though I don&apos;t want to compare them directly. I worked at Fairphone for more than three years at the time of Fairphone 2, and the modular aspect of the phone was amazing. I have been following Framework since they launched a crowdfunding campaign for their first generation modular laptop, it&apos;s a really positive outcome that they are still there and made it to the second generation.</p><p>To be clear, and that argument held already for Fairphone, it&apos;s not about following the trends and getting updated hardware with better specs every (other) year that matters. But if we stay pragmatic, those players with a small ordering/manufacturing volume can simply not sustain electronic parts by themselves. They can only buy what&apos;s made (and kept) available by the bigger players. So yes, after a few years, chips will be end-of-life and you will need to change your blueprints to accomodate for replacement parts. And sometimes you won&apos;t find pin-to-pin compatibile chips, if they are even dimensionally compatible, and you will have to spend more engineering power on retro-fitting new components.</p><p>From a consumer perspective, I am happily using performant hardware from a few years ago without any problem. I don&apos;t <em>need</em> to upgrade. The only part that does not age well is the battery, but it usually can be found new from a third-party supplier.</p><p>Now, let&apos;s see how many times Framework will be able to upgrade their mainboard while maintening the chassis. I believe they came up with a good design leaving every &quot;stable component&quot; off the mainboard. Screens, keyboards, batteries, those things do not change really fast. Unlike CPU, storage, RAM, and other wireless cards. They should be able to keep the base as-is &#x2014;give or take a few refinements as they receive feedback&#x2014; for hopefully a few more generations.</p><p>After this long introduction, let&apos;s go back to the main topic. In April 2022, Framework launched a (community) developer program for their mainboard &quot;to accelerate the ecosystem of projects using Framework Laptop Mainboards&quot;. A month later, they followed suit by announcing their next mainboard generation. The acknowledged goal of the program is to foster many interesting ideas for people to re-use their mainboard when they decide to upgrade their own laptops. And not throw them away or leave them in a drawer. (Also, don&apos;t do that with your phones either. Donate or sell them, please. We have too much dormant electronic waste.)</p><p>My take on this program is to build <em>a transportable computer with a better keyboard</em>. Think early computers where the brain was in the same chassis than the input device. Though I am too young to have experienced that, the idea is quite appealing to me for a mainly sedentary computer. I will distinguish myself from the many similar projects (<a href="https://www.youtube.com/watch?v=y8jiYl0CzKc">that</a> <a href="https://github.com/penk/MainboardTerminal">look</a> <a href="https://github.com/brickbots/framedeck">awesome</a>; and all feature mechanical keyboards) with a more low-key approach: <em>think DIY from your apartment without a workshop</em>. I do not have a 3D printer. I do not know how to use a CAD software. I do not know how to do mechanical engineering. But. I am a serial dreamer. I am having fun. I want to build something accessible (by necessity, but also by choice).</p><p>It&apos;s going to be rough. It&apos;s going to be amateuristic. And that&apos;s fine.</p>]]></content:encoded></item><item><title><![CDATA[The cautionary nightmare]]></title><description><![CDATA[<p>I had a dream. Rather, I had a nightmare last night. It went as dreams go, mixing reality and fantasy. When I awoke, completely stressed out for the day before morning light could stream through my window, I decided I would not let the dream happen. Here is the gist.</p>]]></description><link>https://steadymonkey.eu/the-cautionary-nightnare/</link><guid isPermaLink="false">61b07323b1bb1d00014fd933</guid><category><![CDATA[Homelab]]></category><dc:creator><![CDATA[Borjan Tchakaloff]]></dc:creator><pubDate>Wed, 08 Dec 2021 09:38:15 GMT</pubDate><content:encoded><![CDATA[<p>I had a dream. Rather, I had a nightmare last night. It went as dreams go, mixing reality and fantasy. When I awoke, completely stressed out for the day before morning light could stream through my window, I decided I would not let the dream happen. Here is the gist.</p><p>In that dream, my brand new laptop that I left in the car was stolen. Actually the car itself was stolen, but found later with only the laptop missing. The laptop sleeve was still in the car, though. Clearly that was the first sign this was ridiculous: who would take the time to take the laptop of its protection sleeve before stealing it? Anyway, my laptop is a few years old and I don&apos;t even own a car. Details.</p><p>I got home, frustrated that I lost this new piece of equipment. In the end, it&apos;s only material and that&apos;s a problem money can fix. We will live on. Only to discover that my tower computer was gone too! Arg, thieves broke in the flat and extracted that one piece of hardware. Bad luck, for real. Those sweet SSD and NVMe drives are gone. But, in the end, they were encyrpted and so it&apos;s only a matter of replacing the hardware.</p><p>Now, I was not alarmed beyond measure because I have a (almost) solid back-up plan. That laptop and that tower computer were primary sources of data, their full states backed up to the NAS. So all my data is fine, I thought, proud of myself. I only went to my &quot;office&quot; to discover the NAS was also missing. No way! What kind of bad day can this be? Besides the fact it was yet again more money that evaporated, it can be &quot;easily&quot; replaced with an equivalent off the shelf, this time <em>my whole data was out there</em>.</p><p>I still had my last line of defense in the name of offsite back-ups: the most important data was recoverable, I only lost what I deemed expendable. No, the actual problem was that the NAS is holding raw data. Whatever lands there unencrypted stays there unencrypted. And I feel <em>very</em> uncomfortable with the idea of my whole life being completely exposed. Not that I deal in top secret projects, nor hoard sensitive information. It&apos;s just my private life. I am not wiring public CCTV in my homer for the same reason, it&apos;s my own life and my own affair.</p><p>All of this prose to come to the following points. First, I am confident in my back-up strategy whether my flat burns down or all my hardware gets stolen. What data really matters is also stored elsewhere, I can recover. Second, I am <em>not</em> satisfied with how my data is stored at rest on the NAS. Both primary and ternary data sources are encrypted (computers are using either full disk encryption or logical partition encryption; offsite back-ups are encrypted before leaving my NAS) while the data hoarding source that is my NAS is <em>removing</em> the encryption layer from the primary sources that get synchronised. The data is kept in sync at a file-level, not block-level, so the file-system/partition encryption of the source simply does not apply to the replicate.</p><p>I will have to sacrifice performance for privacy since the NAS does not offer much hardware acceleration in the cryptography area. But again, the trade-off seems acceptable because I am not hoarding files for the sake of archiving. My daily computer back-ups will end up on an encrypted ZFS dataset. That way I can still benefit from the features offered by ZFS (which is why I am pushing files and not blocks in the first place) while resting easy about my private data. The largest files on the NAS (media files) are not backed up because I don&apos;t deem them very important, so I also won&apos;t go through the hassle of encrypting them.</p>]]></content:encoded></item><item><title><![CDATA[More adventures with the NAS]]></title><description><![CDATA[About ten days ago, I received a scary e-mail from the NAS (it has a name by the way, it's called cactus): my boot pool was degraded but still operational. The SSD I added not so long ago to mirror the USB drive actually started to fail.]]></description><link>https://steadymonkey.eu/more-adventures-with-the-nas/</link><guid isPermaLink="false">6194dddcb411d30001345ae4</guid><category><![CDATA[Homelab]]></category><dc:creator><![CDATA[Borjan Tchakaloff]]></dc:creator><pubDate>Wed, 17 Nov 2021 11:14:29 GMT</pubDate><content:encoded><![CDATA[<p>About ten days ago, I received a scary e-mail from the NAS (it has a name by the way, it&apos;s called <em>cactus</em>): my boot pool was degraded but still operational. The SSD I added not so long ago to mirror the USB drive actually started to fail. TrueNAS detected slow read performance, and eventually detached the drive from the pool of its own accord. Smarty pants.</p><p>I was certainly not expecting the SSD to fail before the USB drive (they were roughly as old), especially given that the SSD did not see much wear and that it was stored in an ESD-safe bag together with a desiccant bag.</p><p>I ordered two more SSD drives to replace the current USB drive &#xA0;and the failed SSD, with the intent of switching to a full SSD mirrored boot pool. I also got a USB-to-SATA converter to connect one of the drives to the internal USB port currently used by the USB drive since I only have access to one internal SATA port (remember, the one for the ODD).</p><p>The plan was simple: connect one SSD first to the SATA port, attach it to the boot pool, let the system resilver the pool, detach the USB stick, power-off, swap the USB stick with the second SSD thanks to the USB-SATA adapter, boot on the first SSD, and do the attach-and-resilver dance once more with the second SSD. It should have been a fairly easy and painless process according to the documentation and online discussions. Except that it was not.</p><p>The first problem I encountered was of a surprising nature. Trying to attach the SSD to the boot pool gave the unhelpful error of &quot;can only attach to mirrors and top-level disks&quot;. This is a known UX problem where a few type of errors are aggregated into this high-level exception thrown by TrueNAS&apos; middleware. It is apparently quite common to see this when the block size of the pool and additional disk cannot match. I suspect the initial boot pool was created with a too-small block size (think 512 bytes) while now the recommendation is to go with 4 kilobytes by default. And since the new SSDs have indeed 4k block size, I cannot mix and match them in the existing pool. I did try to make it work for a couple of hours but eventually decided that my mastery level was too low to risk the NAS setup and the time investment needed not worth it. <em>(Not that I would have had the time anyway.)</em></p><p>After reading extensively on how to migrate the TrueNAS boot drive to another medium, I jumped on the fresh install bandwagon. I installed the version I was currently running on the USB stick on the SSD, booted, imported the configuration, and done. It was really simple and it definitely took me longer to read about the procedure (a case of cold feet) than to execute it.</p><p>Now, the idea was to keep a mirror of the boot pool. I wanted to part ways with the USB stick for good and simply use two SSDs. Strangely enough, the second SSD via USB stopped working the moment I installed it inside the NAS. (I did run a couple of tests outside the NAS first, using the external USB ports.) The kernel reported I/O errors and simply backed away from the construct. But only on FreeBSD, I could use the SSD on a GNU/Linux machine without issues.</p><p>This time around, I did not spend too long thinking about the solution: the adapter goes back as DOA and I simply don&apos;t mirror the boot pool. <em>Replacing the boot drive is so easy</em> that I am not afraid of the next failure. I have only so much time to debug weird hardware problems. So for now the USB stick remains plugged in, but as a backup boot disk (it is not part of the running boot pool) &#x2014; that way there is no write on it until the day I need to rescue the system and use it as the boot drive.</p>]]></content:encoded></item><item><title><![CDATA[Upgrading my NAS to TrueNAS Core]]></title><description><![CDATA[<p>Over the course of the week-end, I (finally) upgraded from FreeNAS 11.3 to TrueNAS Core 12.0.</p><p>One of the most notable things with the new version is that it is strongly discouraged to use a USB stick as boot drive. Since my NAS has an internal USB port</p>]]></description><link>https://steadymonkey.eu/upgrading-my-nas-to-truenas-core/</link><guid isPermaLink="false">6175c0545908100001910bab</guid><category><![CDATA[Homelab]]></category><dc:creator><![CDATA[Borjan Tchakaloff]]></dc:creator><pubDate>Sun, 24 Oct 2021 19:23:26 GMT</pubDate><content:encoded><![CDATA[<p>Over the course of the week-end, I (finally) upgraded from FreeNAS 11.3 to TrueNAS Core 12.0.</p><p>One of the most notable things with the new version is that it is strongly discouraged to use a USB stick as boot drive. Since my NAS has an internal USB port for a boot stick, it is of course what I have been using since the beginning: a very small SanDisk Cruzer Fit of 16GB. Good opportunity to use that old (but unused) Intel SSD of 40GB that has been forgotten in the unnamed box of electronics.</p><p>My initial thought was to unplug everything from the motherboard, the data hard drives, the boot USB stick, the ethernet cable, and install TrueNAS on the SSD. Not only is that a bit on the paranoid side, it is also completely unnecessary. It turns out plugging in the SSD and adding it to the ZFS boot pool was enough to seamlessly upgrade my boot storage to a two-disk mirror. As a side-effect, my boot pool is limited by the smaller disk but I now have a <em>mirrored</em> boot pool. Yay for redundancy. 16GB is enough for now anyway, the main disk space use is on OS upgrade to create a new boot environment. That does not happen so often to me (sic).</p><p>It is worth noting that the NAS do have a fifth SATA port, for the optional ODD (Optical Disk Drive). I decided to flash the BIOS with a well-known community mod to allow disabling the IDE mode on this fifth port, thus allowing the full SATA-3Gbps bandwidth.</p><p>If the USB stick comes to fail, I will still be able to boot the NAS from the SSD (which is the boot drive anyway). When that happens, I might get a USB-to-SATA adapter and fit another small SSD somewhere in the NAS enclosure to keep the mirrored boot pool.</p><p>Back to the upgrade: booting off a USB stick with TrueNAS Core 12.0 and selecting the &quot;upgrade&quot; process went as smooth as can be expected. And&#x2026; that&apos;s it, the NAS is up-to-date now. I am still impressed by how little maintenance is actually needed for FreeNAS/TrueNAS. Setting things up do take some time, though.</p>]]></content:encoded></item><item><title><![CDATA[Refreshing my NAS configuration]]></title><description><![CDATA[<p>I setup my Network Attached Storage (NAS) back in 2014 after getting a nice discount on a HP MicroServer of the previous generation. I added some more ECC RAM, fitted four hard drives, installed FreeNAS, and then happily used it to offload my poor computers of all the media and</p>]]></description><link>https://steadymonkey.eu/refreshing-my-nas-configuration/</link><guid isPermaLink="false">6175c0545908100001910baa</guid><category><![CDATA[Homelab]]></category><dc:creator><![CDATA[Borjan Tchakaloff]]></dc:creator><pubDate>Sat, 28 Aug 2021 20:47:14 GMT</pubDate><content:encoded><![CDATA[<p>I setup my Network Attached Storage (NAS) back in 2014 after getting a nice discount on a HP MicroServer of the previous generation. I added some more ECC RAM, fitted four hard drives, installed FreeNAS, and then happily used it to offload my poor computers of all the media and random stuff I had lying around there. When I moved out of the country in 2015, I packed light and left the NAS behind. Until 2021.</p><p>The 2TB hard drives are not so big by today&apos;s standards but I am happy with the 3.4TB total storage space for now (the hard drives are setup in a RAID-Z2 array, allowing me to lose two drives out of four). Of course if I lose a drive, chances are the others will fail soon too. Maybe even during the resilvering (rebuilding the RAID after replacing the faulty drive). <em>A RAID array is not a backup.</em> I read multiple times that 6 drives would give the best trade-off with RAID-Z2, but unless I fit two more 3.5&quot; hard drives in that small space (it&apos;s not hot in there, but the fans and drives are too loud already), it&apos;s not going to happen any time soon.</p><p>I did a few routine maintenance updates of FreeNAS itself, but I am still lagging behind on an unsupported version. The latest version is not even called FreeNAS anymore, it&apos;s <a href="https://www.truenas.com/truenas-core/">TrueNAS CORE</a> now. Though I have to say that after the initial setup, I simply forgot about it and simply used the NFS shares for a bit. It just worked.</p><p>When I configured FreeNAS in 2014, I had no idea about how many datasets I should create and how I should split my data. I simply went with <em>documents</em> (to store my home dirs), <em>media</em> (music, movies, and the like), and <em>raw</em> (everything else that was not nicely sorted such as mirrors of external drives and copies of old (internal) drives before disposing of the hosts).</p><p>I won&apos;t lie, I am still a neophyte when it comes to handling FreeBSD (e.g. the jails) and configuring it. Last week I managed to mess up all file permissions of one of my datasets. Thankfully it was my home dirs mirror, so it does not matter if I blindly reset the permissions to <code>u+rwX,go=</code>. I also realised that I was naive enough to store my NAS user account on that same dataset. So when I reset the permissions, I also set the wrong bits for the SSH configuration and could not login anymore. It took me a shamefully long time to realise why I could not remotely log-in. I finally solved my problem with the help of the console in the FreeNAS UI: one call to <code>chmod</code> later and I could log-in again.</p><p>Here is the new scheme I came up with:</p><ul><li><code>home</code>: simply the home directories of the NAS accounts; I don&apos;t want to stupidly break my SSH configuration anymore</li><li><code>dione</code>, <code>iapetus</code>, &#x2026;: mirrors of the data stored on my everyday computers</li><li><code>media</code>: original dataset for multimedia files &#x2013; still a good idea</li><li><code>raw</code>: original staging dataset of files I am supposed to review and categorise &#x2013; only relevant if I <em>actually</em> move things out of it, otherwise I should rename it to <code>dumpster</code></li></ul><p>The idea of mirroring data from my computers is that I can leverage ZFS snapshots directly on the NAS and not handle a more-or-less complicated, and more-or-less very slow incremental local backup process. I do not work with really big files on my computers. The only time I access big multimedia files is when I travel and I want a local cache of movies/series. I am fine <code>rsync</code>-ing a subset of my filesystem over the wire to the NAS every day.</p><p>I thought that it would be really nice to be able to browse through the snapshots in a user-friendly manner, for instance if I want to restore an older version of a file. After a few days of leaving that train of thoughts on the back-burner, I came to the conclusion that I actually do not need that feature. I don&apos;t care about selective restoration. I don&apos;t need a time machine for individual files because if I do, then I use a version control system (e.g. Git). I imagine that the only times I would need to restore a snapshot are if I have a hardware failure, and if my files end up encrypted by some external entity asking me to pay them in cryptocurrency in exchange for the decryption key. In both cases I can take the time to navigate through manually cloning the snapshots in question and promoting it or restoring from it.</p><p>Next up: switching from <code>D&#xE9;j&#xE0;Dup</code> against Google Drive to <code>rsync</code> to the NAS.</p>]]></content:encoded></item><item><title><![CDATA[Atreus build part 5: Adding external access to the reset pin]]></title><description><![CDATA[<p><em>This post belongs to the </em>Atreus build series<em>, which was introduced by </em><a href="https://steadymonkey.eu/onward-with-the-atreus-keyboard/">Onward with the Atreus keyboard</a>.</p><p>The advantage of building your own mechanical keyboard is that you get to choose the software to run on it. The problem is that you need to place the controller in &quot;flashing</p>]]></description><link>https://steadymonkey.eu/atreus-build-part-5/</link><guid isPermaLink="false">6266f2375112250001f12249</guid><category><![CDATA[Atreus]]></category><dc:creator><![CDATA[Borjan Tchakaloff]]></dc:creator><pubDate>Wed, 24 Jun 2020 08:16:00 GMT</pubDate><content:encoded><![CDATA[<p><em>This post belongs to the </em>Atreus build series<em>, which was introduced by </em><a href="https://steadymonkey.eu/onward-with-the-atreus-keyboard/">Onward with the Atreus keyboard</a>.</p><p>The advantage of building your own mechanical keyboard is that you get to choose the software to run on it. The problem is that you need to place the controller in &quot;flashing mode&quot; to do just that.</p><p>I learnt my mistake and decided to give myself an easier time to play with the keyboard software and give me better access to the reset pin of the Pro Micro.</p><p>I am simply going to expose the upper part of two pins from a plain old header bar which I will solder to the reset and ground pins of the Pro Micro. Then I simply have to short these pins to &quot;hold&quot; reset. A small screwdriver will provide conductivity and reach whenever the need arises.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://steadymonkey.eu/content/images/2022/04/atreus-wire-up-reset-pin-01.jpg" class="kg-image" alt loading="lazy" width="1200" height="900" srcset="https://steadymonkey.eu/content/images/size/w600/2022/04/atreus-wire-up-reset-pin-01.jpg 600w, https://steadymonkey.eu/content/images/size/w1000/2022/04/atreus-wire-up-reset-pin-01.jpg 1000w, https://steadymonkey.eu/content/images/2022/04/atreus-wire-up-reset-pin-01.jpg 1200w" sizes="(min-width: 720px) 720px"><figcaption>Marking where I need to drill on the second layer to open up under the &quot;a&quot; of Atreus. The bolts are simply going through both layers to align them together.</figcaption></figure><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://steadymonkey.eu/content/images/2022/04/atreus-wire-up-reset-pin-02.jpg" class="kg-image" alt loading="lazy" width="1200" height="900" srcset="https://steadymonkey.eu/content/images/size/w600/2022/04/atreus-wire-up-reset-pin-02.jpg 600w, https://steadymonkey.eu/content/images/size/w1000/2022/04/atreus-wire-up-reset-pin-02.jpg 1000w, https://steadymonkey.eu/content/images/2022/04/atreus-wire-up-reset-pin-02.jpg 1200w" sizes="(min-width: 720px) 720px"><figcaption>The hole appears right below the USB-C breakout board and is big enough to fit both pins.</figcaption></figure><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://steadymonkey.eu/content/images/2022/04/atreus-wire-up-reset-pin-03.jpg" class="kg-image" alt loading="lazy" width="1200" height="900" srcset="https://steadymonkey.eu/content/images/size/w600/2022/04/atreus-wire-up-reset-pin-03.jpg 600w, https://steadymonkey.eu/content/images/size/w1000/2022/04/atreus-wire-up-reset-pin-03.jpg 1000w, https://steadymonkey.eu/content/images/2022/04/atreus-wire-up-reset-pin-03.jpg 1200w" sizes="(min-width: 720px) 720px"><figcaption>The reset pins soldered to RST and GND on the Pro Micro. (Note the last minute hand colouring of the wires to distinguish them from the ones used in the switches matrix.)</figcaption></figure><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://steadymonkey.eu/content/images/2022/04/atreus-wire-up-reset-pin-04.jpg" class="kg-image" alt loading="lazy" width="1200" height="900" srcset="https://steadymonkey.eu/content/images/size/w600/2022/04/atreus-wire-up-reset-pin-04.jpg 600w, https://steadymonkey.eu/content/images/size/w1000/2022/04/atreus-wire-up-reset-pin-04.jpg 1000w, https://steadymonkey.eu/content/images/2022/04/atreus-wire-up-reset-pin-04.jpg 1200w" sizes="(min-width: 720px) 720px"><figcaption>Hitting reset on the Pro Micro gets easier: short the two pins in the &quot;a&quot;.</figcaption></figure>]]></content:encoded></item><item><title><![CDATA[Atreus build part 4: Wiring the USB-C breakout board]]></title><description><![CDATA[<p><em>This post belongs to the </em>Atreus build series<em>, which was introduced by </em><a href="https://steadymonkey.eu/onward-with-the-atreus-keyboard/">Onward with the Atreus keyboard</a>.</p><p>The breakout board will give a USB-C socket to the Atreus, much nicer to use than an old &#x2014;though still omnipresent&#x2014; micro-B socket. The breakout board I am using (from Adafruit)</p>]]></description><link>https://steadymonkey.eu/atreus-build-part-4-the-usb-c-breakout-board/</link><guid isPermaLink="false">6266ed595112250001f121e0</guid><category><![CDATA[Atreus]]></category><dc:creator><![CDATA[Borjan Tchakaloff]]></dc:creator><pubDate>Fri, 22 May 2020 10:46:00 GMT</pubDate><content:encoded><![CDATA[<p><em>This post belongs to the </em>Atreus build series<em>, which was introduced by </em><a href="https://steadymonkey.eu/onward-with-the-atreus-keyboard/">Onward with the Atreus keyboard</a>.</p><p>The breakout board will give a USB-C socket to the Atreus, much nicer to use than an old &#x2014;though still omnipresent&#x2014; micro-B socket. The breakout board I am using (from Adafruit) takes care of preparing the signals to force the USB-C end as a downstream device through a set of properly placed resistors. (Downstream devices means it must be connected to a host device, it cannot function on its own or be a host itself.)</p><p>All that is left for me to do is to rip a USB cable with a micro-B plug end that will connect the breakout board to the Pro Micro controller. And be mindful of the connector enclosure thickness as it must fit inside the casing, which in my case gives me 6 millimetres clearance.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://steadymonkey.eu/content/images/2022/04/atreus-wire-up-breakout-board-01.jpg" class="kg-image" alt loading="lazy" width="1200" height="900" srcset="https://steadymonkey.eu/content/images/size/w600/2022/04/atreus-wire-up-breakout-board-01.jpg 600w, https://steadymonkey.eu/content/images/size/w1000/2022/04/atreus-wire-up-breakout-board-01.jpg 1000w, https://steadymonkey.eu/content/images/2022/04/atreus-wire-up-breakout-board-01.jpg 1200w" sizes="(min-width: 720px) 720px"><figcaption>Soldering the four wires of USB 2.0, those wires are thin and I cut them quite short.</figcaption></figure><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://steadymonkey.eu/content/images/2022/04/atreus-wire-up-breakout-board-02.jpg" class="kg-image" alt loading="lazy"><figcaption>USB-C breakout board (socket) soldered to USB micro-B plug.</figcaption></figure><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://steadymonkey.eu/content/images/2022/04/atreus-wire-up-breakout-board-04.jpg" class="kg-image" alt loading="lazy" width="1200" height="900" srcset="https://steadymonkey.eu/content/images/size/w600/2022/04/atreus-wire-up-breakout-board-04.jpg 600w, https://steadymonkey.eu/content/images/size/w1000/2022/04/atreus-wire-up-breakout-board-04.jpg 1000w, https://steadymonkey.eu/content/images/2022/04/atreus-wire-up-breakout-board-04.jpg 1200w" sizes="(min-width: 720px) 720px"><figcaption>The USB-C board and socket fit nicely thanks to a couple of nuts. Considering the materials (wood does flex) and the operator&apos;s skills, it&apos;s as close to perfect as it can be. The outmost external nuts are holding the layers temporarily for the photo shoot.</figcaption></figure><p>Once that is done, the micro-B plug can be connected to the Pro Micro and the casing assembled.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://steadymonkey.eu/content/images/2022/04/atreus-wire-up-breakout-board-12.jpg" class="kg-image" alt loading="lazy" width="1200" height="900" srcset="https://steadymonkey.eu/content/images/size/w600/2022/04/atreus-wire-up-breakout-board-12.jpg 600w, https://steadymonkey.eu/content/images/size/w1000/2022/04/atreus-wire-up-breakout-board-12.jpg 1000w, https://steadymonkey.eu/content/images/2022/04/atreus-wire-up-breakout-board-12.jpg 1200w" sizes="(min-width: 720px) 720px"><figcaption>The keyboard fully assembled, with keycaps on.</figcaption></figure><p><strong>Edit:</strong> And a picture of the how the breakout board is tightly fitting at the edge of the casing. This gives a bit more perspective as to why the USB plug wires were cut so short.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://steadymonkey.eu/content/images/2022/04/atreus-wire-up-breakout-board-13.jpg" class="kg-image" alt loading="lazy" width="1200" height="900" srcset="https://steadymonkey.eu/content/images/size/w600/2022/04/atreus-wire-up-breakout-board-13.jpg 600w, https://steadymonkey.eu/content/images/size/w1000/2022/04/atreus-wire-up-breakout-board-13.jpg 1000w, https://steadymonkey.eu/content/images/2022/04/atreus-wire-up-breakout-board-13.jpg 1200w" sizes="(min-width: 720px) 720px"><figcaption>Upside-down, bottom-up, view of the USB-C breakout board connected to the Pro Micro.</figcaption></figure>]]></content:encoded></item><item><title><![CDATA[Atreus build part 3: Wiring up the switches]]></title><description><![CDATA[<p><em>This post belongs to the </em>Atreus build series<em>, which was introduced by </em><a href="https://steadymonkey.eu/onward-with-the-atreus-keyboard/">Onward with the Atreus keyboard</a>.</p><p>Last night I started soldering the rows and columns. The rows are connected by diodes (to avoid a bounce back effect from residual current on key up) while the columns are simply wired</p>]]></description><link>https://steadymonkey.eu/atreus-build-part-3-wiring-up-the-switches/</link><guid isPermaLink="false">626056e46d50b20001e659b0</guid><category><![CDATA[Atreus]]></category><dc:creator><![CDATA[Borjan Tchakaloff]]></dc:creator><pubDate>Fri, 22 May 2020 09:55:00 GMT</pubDate><content:encoded><![CDATA[<p><em>This post belongs to the </em>Atreus build series<em>, which was introduced by </em><a href="https://steadymonkey.eu/onward-with-the-atreus-keyboard/">Onward with the Atreus keyboard</a>.</p><p>Last night I started soldering the rows and columns. The rows are connected by diodes (to avoid a bounce back effect from residual current on key up) while the columns are simply wired together. This multiplexing allows us to only need as many digital inputs as there are columns and rows (11 + 4, the middle thumb keys are in a column of their own).</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://steadymonkey.eu/content/images/2022/04/atreus-wire-up-00.jpg" class="kg-image" alt loading="lazy" width="1200" height="900" srcset="https://steadymonkey.eu/content/images/size/w600/2022/04/atreus-wire-up-00.jpg 600w, https://steadymonkey.eu/content/images/size/w1000/2022/04/atreus-wire-up-00.jpg 1000w, https://steadymonkey.eu/content/images/2022/04/atreus-wire-up-00.jpg 1200w" sizes="(min-width: 720px) 720px"><figcaption>Soldering the diodes to the left pin and connecting them in parallel(!), row by row.</figcaption></figure><p>I wanted to have an easy time (visually) tracing the columns so I mirrored the wire colours along the vertical middle axis. Satisfying to look at.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://steadymonkey.eu/content/images/2022/04/atreus-wire-up-03.jpg" class="kg-image" alt loading="lazy" width="1200" height="900" srcset="https://steadymonkey.eu/content/images/size/w600/2022/04/atreus-wire-up-03.jpg 600w, https://steadymonkey.eu/content/images/size/w1000/2022/04/atreus-wire-up-03.jpg 1000w, https://steadymonkey.eu/content/images/2022/04/atreus-wire-up-03.jpg 1200w" sizes="(min-width: 720px) 720px"><figcaption>Each column connects four switches together, by their right pin. The inner most column only has two switches in it.</figcaption></figure><p>Once all the switches are wired and ready to be connected to the micr-controller, I <em>really </em>realised how a tight fit it would be. Best to wire the Pro Micro upfront to then solder the long loose wires to the rows and columns.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://steadymonkey.eu/content/images/2022/04/atreus-wire-up-05.jpg" class="kg-image" alt loading="lazy" width="1200" height="900" srcset="https://steadymonkey.eu/content/images/size/w600/2022/04/atreus-wire-up-05.jpg 600w, https://steadymonkey.eu/content/images/size/w1000/2022/04/atreus-wire-up-05.jpg 1000w, https://steadymonkey.eu/content/images/2022/04/atreus-wire-up-05.jpg 1200w" sizes="(min-width: 720px) 720px"><figcaption>Each digital input/output is soldered to a piece of wire before hand.</figcaption></figure><p>To keep the standard mapping of columns to digital I/O expected by the firmware, I used the same colour coding for the loose wires. Then it&apos;s simply about soldering wires by colour.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://steadymonkey.eu/content/images/2022/04/atreus-wire-up-06.jpg" class="kg-image" alt loading="lazy" width="1200" height="900" srcset="https://steadymonkey.eu/content/images/size/w600/2022/04/atreus-wire-up-06.jpg 600w, https://steadymonkey.eu/content/images/size/w1000/2022/04/atreus-wire-up-06.jpg 1000w, https://steadymonkey.eu/content/images/2022/04/atreus-wire-up-06.jpg 1200w" sizes="(min-width: 720px) 720px"><figcaption>Getting ready to solder all rows and columns to the micro-controller.</figcaption></figure><p>I finished soldering early morning and then went to bed, satisfied with my good work (or so I thought). I was surprised to realise only half of the keyboard was registering key presses this morning. I forgot to connect both ends of each row, duh.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://steadymonkey.eu/content/images/2022/04/atreus-wire-up-08.jpg" class="kg-image" alt loading="lazy" width="1200" height="900" srcset="https://steadymonkey.eu/content/images/size/w600/2022/04/atreus-wire-up-08.jpg 600w, https://steadymonkey.eu/content/images/size/w1000/2022/04/atreus-wire-up-08.jpg 1000w, https://steadymonkey.eu/content/images/2022/04/atreus-wire-up-08.jpg 1200w" sizes="(min-width: 720px) 720px"><figcaption>Final look after soldering the micro-controller. The micro-controller is only secured with the soldered wires, no additional hot glue. The USB-C breakout board will come next.</figcaption></figure><p>I now have a fully functional 42-key keyboard! But it&apos;s connected with a non-detachable (because inside the case) micro-B USB cable. Next up: soldering the USB-C breakout board to a loose male micro-B cable and fitting it in the case.</p>]]></content:encoded></item><item><title><![CDATA[Atreus build part 2: Glueing the switches]]></title><description><![CDATA[<p><em>This post belongs to the </em>Atreus build series<em>, which was introduced by </em><a href="https://steadymonkey.eu/onward-with-the-atreus-keyboard/">Onward with the Atreus keyboard</a>.</p><p>Today I glued the switches on the base plate (the layer that holds them, commonly made of metal to avoid cave-in when typing energetically). It turned out to be more cumbersome than anticipated.</p>]]></description><link>https://steadymonkey.eu/atreus-build-part-2-glueing-the-switches/</link><guid isPermaLink="false">626058356d50b20001e659c7</guid><category><![CDATA[Atreus]]></category><dc:creator><![CDATA[Borjan Tchakaloff]]></dc:creator><pubDate>Wed, 20 May 2020 18:26:00 GMT</pubDate><content:encoded><![CDATA[<p><em>This post belongs to the </em>Atreus build series<em>, which was introduced by </em><a href="https://steadymonkey.eu/onward-with-the-atreus-keyboard/">Onward with the Atreus keyboard</a>.</p><p>Today I glued the switches on the base plate (the layer that holds them, commonly made of metal to avoid cave-in when typing energetically). It turned out to be more cumbersome than anticipated. Especially if you glue up the switches in the wrong direction&#x2026;</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://steadymonkey.eu/content/images/2022/04/atreus-glue-up-00.jpg" class="kg-image" alt loading="lazy" width="1200" height="900" srcset="https://steadymonkey.eu/content/images/size/w600/2022/04/atreus-glue-up-00.jpg 600w, https://steadymonkey.eu/content/images/size/w1000/2022/04/atreus-glue-up-00.jpg 1000w, https://steadymonkey.eu/content/images/2022/04/atreus-glue-up-00.jpg 1200w" sizes="(min-width: 720px) 720px"><figcaption>All switches glued on the base plate (viewed from under) holding the switches. Switches with a black underside are Gateron Brown while the Kailh Pro Burgundy have a white underside.</figcaption></figure><p>Once all the switches were glued up, I decided to make sure they were all working correctly. Just in case QA let something slipped under their radar. (Or if I broke one with my inexperienced handling.) I flashed <a href="https://qmk.fm/">QMK</a> (there is direct support for <a href="https://github.com/qmk/qmk_firmware/tree/master/keyboards/atreus/promicro">the Atreus Pro Micro</a>) to the Pro Micro and soldered two wires. Then I plugged it in my computer, and started a keyboard testing tool (<a href="https://config.qmk.fm/#/test/">QMK has a nice page</a> showing exactly which (combination of) key gets pressed; but any text input such as a text editor or terminal would have worked as long as the wires are shorting a pin mapped to a letter).</p><p>I held the dangling wires to each pair of switch pins while pressing the whole plate down on the table. Don&apos;t judge me, it worked fine.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://steadymonkey.eu/content/images/2022/04/atreus-glue-up-01.jpg" class="kg-image" alt loading="lazy" width="1200" height="900" srcset="https://steadymonkey.eu/content/images/size/w600/2022/04/atreus-glue-up-01.jpg 600w, https://steadymonkey.eu/content/images/size/w1000/2022/04/atreus-glue-up-01.jpg 1000w, https://steadymonkey.eu/content/images/2022/04/atreus-glue-up-01.jpg 1200w" sizes="(min-width: 720px) 720px"><figcaption>Each switch was tested individually.</figcaption></figure>]]></content:encoded></item><item><title><![CDATA[Atreus build part 1: Dry fitting the keyboard parts]]></title><description><![CDATA[<p><em>This post begins the </em>Atreus build series<em>, which was introduced by </em><a href="https://steadymonkey.eu/onward-with-the-atreus-keyboard/">Onward with the Atreus keyboard</a>.</p><p>I received the laser-cut sheet of plywood yesterday. This time I will let pictures speak for themselves.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://steadymonkey.eu/content/images/2022/04/atreus-dry-fitting-00.jpg" class="kg-image" alt loading="lazy" width="1200" height="900" srcset="https://steadymonkey.eu/content/images/size/w600/2022/04/atreus-dry-fitting-00.jpg 600w, https://steadymonkey.eu/content/images/size/w1000/2022/04/atreus-dry-fitting-00.jpg 1000w, https://steadymonkey.eu/content/images/2022/04/atreus-dry-fitting-00.jpg 1200w" sizes="(min-width: 720px) 720px"><figcaption>Laser-cut plywood sheet of the individual Atreus casing elements.</figcaption></figure><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://steadymonkey.eu/content/images/2022/04/atreus-dry-fitting-05.jpg" class="kg-image" alt loading="lazy" width="1200" height="900" srcset="https://steadymonkey.eu/content/images/size/w600/2022/04/atreus-dry-fitting-05.jpg 600w, https://steadymonkey.eu/content/images/size/w1000/2022/04/atreus-dry-fitting-05.jpg 1000w, https://steadymonkey.eu/content/images/2022/04/atreus-dry-fitting-05.jpg 1200w" sizes="(min-width: 720px) 720px"><figcaption>Individual casing elements, lightly sanded and coated with</figcaption></figure>]]></description><link>https://steadymonkey.eu/atreus-build-part-1-dry-fitting-the-keyboard-parts/</link><guid isPermaLink="false">626017a96d50b20001e65956</guid><category><![CDATA[Atreus]]></category><dc:creator><![CDATA[Borjan Tchakaloff]]></dc:creator><pubDate>Sat, 16 May 2020 21:01:00 GMT</pubDate><content:encoded><![CDATA[<p><em>This post begins the </em>Atreus build series<em>, which was introduced by </em><a href="https://steadymonkey.eu/onward-with-the-atreus-keyboard/">Onward with the Atreus keyboard</a>.</p><p>I received the laser-cut sheet of plywood yesterday. This time I will let pictures speak for themselves.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://steadymonkey.eu/content/images/2022/04/atreus-dry-fitting-00.jpg" class="kg-image" alt loading="lazy" width="1200" height="900" srcset="https://steadymonkey.eu/content/images/size/w600/2022/04/atreus-dry-fitting-00.jpg 600w, https://steadymonkey.eu/content/images/size/w1000/2022/04/atreus-dry-fitting-00.jpg 1000w, https://steadymonkey.eu/content/images/2022/04/atreus-dry-fitting-00.jpg 1200w" sizes="(min-width: 720px) 720px"><figcaption>Laser-cut plywood sheet of the individual Atreus casing elements.</figcaption></figure><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://steadymonkey.eu/content/images/2022/04/atreus-dry-fitting-05.jpg" class="kg-image" alt loading="lazy" width="1200" height="900" srcset="https://steadymonkey.eu/content/images/size/w600/2022/04/atreus-dry-fitting-05.jpg 600w, https://steadymonkey.eu/content/images/size/w1000/2022/04/atreus-dry-fitting-05.jpg 1000w, https://steadymonkey.eu/content/images/2022/04/atreus-dry-fitting-05.jpg 1200w" sizes="(min-width: 720px) 720px"><figcaption>Individual casing elements, lightly sanded and coated with beeswax. The two additional spacers at the bottom are spares.</figcaption></figure><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://steadymonkey.eu/content/images/2022/04/atreus-dry-fitting-03-1.jpg" class="kg-image" alt loading="lazy" width="1200" height="900" srcset="https://steadymonkey.eu/content/images/size/w600/2022/04/atreus-dry-fitting-03-1.jpg 600w, https://steadymonkey.eu/content/images/size/w1000/2022/04/atreus-dry-fitting-03-1.jpg 1000w, https://steadymonkey.eu/content/images/2022/04/atreus-dry-fitting-03-1.jpg 1200w" sizes="(min-width: 720px) 720px"><figcaption>Close-up of the casing layers, from top (foreground) to bottom (background).</figcaption></figure><figure class="kg-card kg-gallery-card kg-width-wide kg-card-hascaption"><div class="kg-gallery-container"><div class="kg-gallery-row"><div class="kg-gallery-image"><img src="https://steadymonkey.eu/content/images/2022/04/atreus-dry-fitting-08.jpg" width="1200" height="900" loading="lazy" alt srcset="https://steadymonkey.eu/content/images/size/w600/2022/04/atreus-dry-fitting-08.jpg 600w, https://steadymonkey.eu/content/images/size/w1000/2022/04/atreus-dry-fitting-08.jpg 1000w, https://steadymonkey.eu/content/images/2022/04/atreus-dry-fitting-08.jpg 1200w" sizes="(min-width: 720px) 720px"></div><div class="kg-gallery-image"><img src="https://steadymonkey.eu/content/images/2022/04/atreus-dry-fitting-06.jpg" width="1200" height="900" loading="lazy" alt srcset="https://steadymonkey.eu/content/images/size/w600/2022/04/atreus-dry-fitting-06.jpg 600w, https://steadymonkey.eu/content/images/size/w1000/2022/04/atreus-dry-fitting-06.jpg 1000w, https://steadymonkey.eu/content/images/2022/04/atreus-dry-fitting-06.jpg 1200w" sizes="(min-width: 720px) 720px"></div></div></div><figcaption>Dry fitting the casing with key switches and breakout board.</figcaption></figure><p>Note the short clearance under the key switches pins, there isn&apos;t much space for wiring under the switches, it will have to be done alongside the switch pins. That is, I could use one or two of the additional spacers I could fit on the plywood sheet but I will try to keep the casing as thin as possible.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://steadymonkey.eu/content/images/2022/04/atreus-dry-fitting-09.jpg" class="kg-image" alt loading="lazy" width="1200" height="900" srcset="https://steadymonkey.eu/content/images/size/w600/2022/04/atreus-dry-fitting-09.jpg 600w, https://steadymonkey.eu/content/images/size/w1000/2022/04/atreus-dry-fitting-09.jpg 1000w, https://steadymonkey.eu/content/images/2022/04/atreus-dry-fitting-09.jpg 1200w" sizes="(min-width: 720px) 720px"><figcaption>The clearance under the key switches is rather short when using two spacers (3mm each).</figcaption></figure><p>I am very happy with my change to the spacers to accommodate for the USB-C breakout board, it looks good with the snug fit and rounder corners.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://steadymonkey.eu/content/images/2022/04/atreus-dry-fitting-11-1.jpg" class="kg-image" alt loading="lazy" width="1200" height="900" srcset="https://steadymonkey.eu/content/images/size/w600/2022/04/atreus-dry-fitting-11-1.jpg 600w, https://steadymonkey.eu/content/images/size/w1000/2022/04/atreus-dry-fitting-11-1.jpg 1000w, https://steadymonkey.eu/content/images/2022/04/atreus-dry-fitting-11-1.jpg 1200w" sizes="(min-width: 720px) 720px"><figcaption>The spacers differ from the original Atreus to leave enough room for the USB-C breakout board.</figcaption></figure><p>Next step: glueing the key switches and wiring things up.</p>]]></content:encoded></item><item><title><![CDATA[Onward with the Atreus keyboard]]></title><description><![CDATA[<p>In the last few months, on a quest to find a better keyboard, I&apos;ve become totally engrossed with the <a href="https://atreus.technomancy.us/">Atreus keyboard</a>, a 42-key mechanical keyboard you can build yourself. Two weeks ago, I placed an order for <a href="https://shop.keyboard.io/products/keyboardio-atreus">the Keyboard.io Atreus</a>, which features two more keys and will</p>]]></description><link>https://steadymonkey.eu/onward-with-the-atreus-keyboard/</link><guid isPermaLink="false">625ff5846d50b20001e6585d</guid><category><![CDATA[Atreus]]></category><dc:creator><![CDATA[Borjan Tchakaloff]]></dc:creator><pubDate>Mon, 11 May 2020 13:07:00 GMT</pubDate><content:encoded><![CDATA[<p>In the last few months, on a quest to find a better keyboard, I&apos;ve become totally engrossed with the <a href="https://atreus.technomancy.us/">Atreus keyboard</a>, a 42-key mechanical keyboard you can build yourself. Two weeks ago, I placed an order for <a href="https://shop.keyboard.io/products/keyboardio-atreus">the Keyboard.io Atreus</a>, which features two more keys and will be manufactured out of metal and plastic. But I am way too excited to wait for another three months until the estimated delivery date. I will build my own Atreus keyboard in the mean time.</p><p>It all started with QWERTY and my poor touch touping. I use only a few fingers (mainly the index and thumb) and my hands are complaining after long keyboard sessions (i.e. kind of every day at the end of my work day). That&apos;s a known problem with QWERTY, it simply is a bad layout for modern hardware.</p><p>Exploring alternative keyboard layouts will invariably expose you to switching keyboard <em>shape</em> as well: ortholinear, &quot;ergonomic&quot;, split, and other niche form factors. And what about the tactile feedback? Most of the less widespread keyboards are mechanical, and I have to admit I too prefer the feeling of mechanical switches than of rubber dome.</p><p>Why switching from 100-ish keys to only so few? I mainly use the alpha-numeric keys, some modifier keys, and special keys (arrows, home, end, etc.). I basically don&apos;t use function keys nor the keypad at all. (Unless I am on Windows, which does not happen very often.) And since a key can fulfil multiple roles based on what &quot;layer&quot; is active (i.e. caps lock) or what modifier key is actively pressed at the same time, it should not be a problem to adapt to more roles instead of more hand movements.</p><p>I like the Atreus overall shape, tiny footprint, and open-ness. I feel like 42 keys ought to be enough, is it even too many keys?</p><p>My plan is to build a regular Atreus but I want a USB-C connector. USB micro-B and mini-B are things of the past. (I am being dramatic here, my point is that I am tired of needing three attempts to connect a USB cable.) Due to the low availability of USB-C keyboard controllers &#x2013;or expensive shipping fees&#x2013;, I ordered a classic (Arduino-ish) Pro Micro controller which I will pair to <a href="https://www.adafruit.com/product/4090">a simple USB-C breakout board from Adafruit</a>, inside the keyboard casing. I also ordered some Gateron Brown switches (i.e. Cherry MX brown -ish) and some Kailh Pro Burgundy switches (i.e. Cherry MX red -ish) for the modifier keys (keys meant to be held don&apos;t need tactile feedback).</p><p>Today, I ordered the laser-cut pieces of the keyboard body from a local shop. I did <a href="https://github.com/bibz/atreus/commit/3625c73b4adb9e245375f933fccaffe4bfa8646c">slightly change the case</a> to fit extra screws for the breakout board. And fit everything on a single sheet of plywood to optimise waste/reduce cost. This is really happening!</p>]]></content:encoded></item><item><title><![CDATA[A reentrant context manager in Python]]></title><description><![CDATA[A Python context manager caters for the boilerplate wrapping a resource to offer safety and convenient (re-)use. Upgrading a context manager to be reentrant is a simple and efficient way to allow a scope to be shared, without changing the context semantics.]]></description><link>https://steadymonkey.eu/a-reentrant-context-manager-in-python/</link><guid isPermaLink="false">6175c0545908100001910ba8</guid><category><![CDATA[Python]]></category><dc:creator><![CDATA[Borjan Tchakaloff]]></dc:creator><pubDate>Sun, 05 Jan 2020 18:43:10 GMT</pubDate><content:encoded><![CDATA[<p>A Python context manager caters for the boilerplate wrapping a resource to offer safety and convenient (re-)use. This protocol ensures that once the context is initialised, it will be torn down whatever happens. Examples of resource handling are input/output operations, session management, thread locking, etc. In this article, we will take a focus peek at one &quot;<a href="https://www.python.org/dev/peps/pep-0020/#the-zen-of-python">honking great idea</a>&quot;: a <strong>reentrant context manager</strong>.</p><p>There has been <a href="http://johnj.com/intro-to-context-managers-in-python.html">many</a> <a href="https://book.pythontips.com/en/latest/context_managers.html">articles</a> and pages of <a href="https://en.wikibooks.org/wiki/Python_Programming/Context_Managers">documentation</a> to explain why context managers are a good thing, and why you would want to <a href="https://jeffknupp.com/blog/2016/03/07/python-with-context-managers/">always<em> </em>handle your resources</a> with them.</p><p>Drawing from classic computer science principles, we propose here to extend the <em>context manager</em> with the <em>reentrant</em> principle to achieve a simple, yet powerful, resource management.</p><h2 id="our-case-study-a-data-store">Our case study: a data store</h2><p>Suppose you are writing a library for a (remote) service. It could be that you want to offer a nice Python interface for your own service, or simply that you want to abstract the service itself from your business code &#x2014; a <a href="https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html">sound idea</a>.</p><p>Our example service is a data store. A user can push, and then pull, arbitrary data from it. Any data that is stored there is associated to a unique identifier. Later, and at one&apos;s request, the identifier can be used to pull the data out of the store once and for all. The store will forget about that piece of data.</p><pre><code class="language-python"># datastore.py
from abc import ABC, abstractmethod


Content = bytes
Identifier = str


class Datastore(ABC):

    @abstractmethod
    def push(self, content: Content) -&gt; Identifier:
        ...

    @abstractmethod
    def pull(self, identifier: Identifier) -&gt; Content:
        ...
</code></pre><p>The interface is simple and clean. <code>Datastore</code> is an <a href="https://docs.python.org/3/glossary.html#term-abstract-base-class">abstract class</a> with two public (abstract) methods.</p><p>Let&apos;s create an in-memory datastore to mock the service and trace the interface calls:</p><pre><code class="language-python"># mock_datastore.py
import logging
from uuid import uuid4

from datastore import Content, Datastore, Identifier


class InMemoryDatastore(Datastore):

    _log = logging.getLogger(&apos;InMemoryDatastore&apos;)
    _store = []

    def push(self, content):
        identifier = str(uuid4())
        self._log.debug(&apos;PUSH: %s with %s bytes&apos;, identifier, len(content))
        self._store[identifier] = content
        return identifier

    def pull(self, identifier):
        if identifier not in self._store:
            raise KeyError(f&quot;Unknown identifier {identifier!r}&quot;)
        self._log.debug(f&apos;PULL: %s&apos;, identifier)
        content = self._store.pop(identifier)
        return content
</code></pre><p>We can now store and retrieve content from a datastore:</p><pre><code class="language-python">&gt;&gt;&gt; import logging
&gt;&gt;&gt; logging.basicConfig(level=logging.DEBUG)
&gt;&gt;&gt; from mock_datastore import InMemoryDatastore as MockDatastore
&gt;&gt;&gt; client = MockDatastore()
&gt;&gt;&gt; i = client.push(b&apos;an entry&apos;)
DEBUG:InMemoryDatastore:PUSH: 53d387c9-8d96-4ca8-a1c5-f6d5efffc572 with 8 bytes
&gt;&gt;&gt; client.pull(i)
DEBUG:InMemoryDatastore:PULL: 53d387c9-8d96-4ca8-a1c5-f6d5efffc572
b&apos;an entry&apos;
</code></pre><h2 id="-for-authenticated-users">&#x2026; for authenticated users</h2><p>Say there is a new requirement: all actions undertook against the data store must be authenticated. The client interface should handle this and provide a construct to deal with <em>sessions</em>. There is no need for the interface consumer to have to manually log in and out, we will not change the <code>Datastore</code> interface. The library we are writing is supposed to <em>help</em> the consumer, not clutter its interface.</p><p>We will define the authentication methods as &quot;private/protected&quot; and use them to push and pull data to the data store, from the implementation classes themselves. To avoid repeating ourselves, we simply define a new interface:</p><pre><code class="language-python"># authenticated_datastore.py

from abc import abstractmethod
from contextlib import contextmanager

from datastore import Datastore


AuthToken = str


class AuthenticatedDatastore(Datastore):

    @abstractmethod
    def push(self, content):
        ...

    @abstractmethod
    def pull(self, identifier):
        ...

    @abstractmethod
    def _login(self, credentials) -&gt; AuthToken:
        ...

    @abstractmethod
    def _logout(self, token: AuthToken):
        ...
</code></pre><p>Good programmers are lazy, they say. Programmers always want to make things silly simple and efficient. I could not agree more, especially if there is an exposed interface at play.</p><p>The implementation classes have to remember to call <code>_logout()</code> every time they call <code>_login()</code>. What happens to us when we burden ourselves with hand-woven resource management? Things break, memory leaks, and we become sad.</p><p>The authentication as we just defined it <strong>is a resource</strong> that we manage: we have to create (<em>to log in</em>) and destroy (<em>to log out</em>) each instance we handle (<em>a session</em>). Let&apos;s take a look at a nifty solution Python offers us: the context manager.</p><h2 id="what-a-context-manager-is-by-example">What a context manager is, by example</h2><p>The Python documentation describes <a href="https://docs.python.org/3/reference/datamodel.html#context-managers">a context manager</a> as:</p><blockquote>[&#x2026;] an object that defines the runtime context to be established when executing a <code>with</code> statement. The context manager handles the entry into, and the exit from, the desired runtime context for the execution of the block of code.</blockquote><p>Said differently, the scope of a context manager is tied to an object life-cycle. But instead of the regular <em>initialisation</em> and <em>destruction</em> of the object, a different protocol is used (aptly named&#x2026; <a href="https://docs.python.org/3/library/stdtypes.html#typecontextmanager">Context Manager</a>). It defines the interface for <em>entry</em> and <em>exit</em> of the scope.</p><p>We described earlier our resource as <em>an authentication session</em>. Its actions were <em>to log in</em> and <em>to log out</em>. Simply translated to Python into a new mock:</p><pre><code class="language-python">from authenticated_datastore import AuthToken, AuthenticatedDatastore


class InMemoryAuthenticatedDatastore(InMemoryDatastore):

    _log = logging.getLogger(&apos;InMemoryAuthenticatedDatastore&apos;)
    credentials = &apos;foo:bar&apos;

    @contextmanager
    def _session(self):
        session_token = self._login(self.credentials)
        try:
            yield
        finally:
            self._logout(session_token)

    @abstractmethod
    def _login(self, credentials) -&gt; AuthToken:
        token = hash(credentials)
        self._log.debug(&apos;LOGIN: %s&apos;, token)
        return token

    @abstractmethod
    def _logout(self, token: AuthToken):
        self._log.debug(&apos;LOGOUT: %s&apos;, token)

    def push(self, content):
        with self._session():
            return super().push(content)

    def pull(self, identifier):
        with self._session():
            return super().push(content)</code></pre><p>The session context manager is built so that once we are successfully logged in &#x2014; when we enter the scope of the <code>with</code> block &#x2014; we will always log out <em>no matter what happens</em>. Indeed, thanks to the generator-like approach in our context manager, we <em>yield</em> within the scope of the <code>try</code> block. We exit this block only when the yield returns &#x2014; that is, when the <code>with</code> scope is exited from the calling block.</p><p>Basically, that means that even if an exception is raised when we are within the scope of the session context manager, the session will be torn down before the exception ripples up:</p><pre><code class="language-python">&gt;&gt;&gt; import logging
&gt;&gt;&gt; logging.basicConfig(level=logging.DEBUG)
&gt;&gt;&gt; from mock_datastore import InMemoryAuthenticatedDatastore as MockDatastore
&gt;&gt;&gt; client = MockDatastore()
&gt;&gt;&gt; i = client.push(b&apos;an entry&apos;)
DEBUG:InMemoryAuthenticatedDatastore:LOGIN: 5444710130385190768
DEBUG:InMemoryAuthenticatedDatastore:PUSH: f0d4dc6b-38fa-485d-b96d-0ced4c10c382 with 8 bytes
DEBUG:InMemoryAuthenticatedDatastore:LOGOUT: 5444710130385190768
&gt;&gt;&gt; c = client.pull(i)
DEBUG:InMemoryAuthenticatedDatastore:LOGIN: 5444710130385190768
DEBUG:InMemoryAuthenticatedDatastore:PULL: f0d4dc6b-38fa-485d-b96d-0ced4c10c382
DEBUG:InMemoryAuthenticatedDatastore:LOGOUT: 5444710130385190768
&gt;&gt;&gt; print(c)
b&apos;an entry
&gt;&gt;&gt; client.pull(i)
DEBUG:InMemoryAuthenticatedDatastore:LOGIN: 5444710130385190768
DEBUG:InMemoryAuthenticatedDatastore:LOGOUT: 5444710130385190768
Traceback (most recent call last):
  ...
    raise KeyError(f&quot;Unknown identifier {identifier!r}&quot;)
KeyError: &quot;Unknown identifier &apos;f0d4dc6b-38fa-485d-b96d-0ced4c10c382&apos;&quot;
</code></pre><h2 id="performing-many-operations">Performing many operations</h2><p>As we just saw, each operation handles its own session scope. From an interface point of view, this is great, the datastore library is responsible for its own success and the library clients do not have to know about the session details. This also allows us to configure a datastore service (<code>Datastore</code> and its children) at instantiation time and then forget about the service details. Perfect for dependency injection.</p><p>But calling many operations sequentially is far from ideal. Each operation will initiate a new session, perform its action, and then close the session. In our mono-threaded example, we are taking the network hit every single time we request a service operation.</p><p>Conversely, when a consumer wants to perform batch operations, it would be beneficial to open only one session, perform all operations, and only then close the session.</p><p>Let us see what trace we get if we try this with our current session context manager:</p><pre><code class="language-python">&gt;&gt;&gt; from mock_datastore import InMemoryDatastore as MockDatastore
&gt;&gt;&gt; client = MockDatastore()
&gt;&gt;&gt; with client._session():
...     i = client.push(&apos;another entry&apos;)
...     client.pull(i)
... 
DEBUG:InMemoryAuthenticatedDatastore:LOGIN: 5444710130385190768
DEBUG:InMemoryAuthenticatedDatastore:LOGIN: 5444710130385190768
DEBUG:InMemoryAuthenticatedDatastore:PUSH: 3034f5e6-3ee8-42cb-b22e-48901afb1097 with 13 bytes
DEBUG:InMemoryAuthenticatedDatastore:LOGOUT: 5444710130385190768
DEBUG:InMemoryAuthenticatedDatastore:LOGIN: 5444710130385190768
DEBUG:InMemoryAuthenticatedDatastore:PULL: 3034f5e6-3ee8-42cb-b22e-48901afb1097
DEBUG:InMemoryAuthenticatedDatastore:LOGOUT: 5444710130385190768
&apos;another entry&apos;
DEBUG:InMemoryAuthenticatedDatastore:LOGOUT: 5444710130385190768</code></pre><p>The current behaviour is clearly not what we want, we now even have one more session wrapping everything else!</p><p>In a lucky scenario, the remote service behaves nicely and re-use the existing session whenever we try to authenticate ourselves again. But unless this is an explicit service feature, we really should cater for this locally, in the library.</p><h2 id="re-using-the-existing-session-or-the-reentrant-context-manager">Re-using the existing session, or the reentrant context manager</h2><p>The idea driving our use-case is that we keep a session open until it has served its purpose. We can only achieve this by <em>remembering</em> that there is an open session already. And when a request for a session pops up, through a call to the session context manager, we can safely re-use the existing session instead of asking for a new one.</p><p>In computer science, this concept is famously applied to locks. A simple lock can be acquired once. Before any new acquiring, even by the current holder, the simple lock must be released. On the other hand, a reentrant lock can be acquired time and again by its current holder.</p><p>Our dummy in-memory datastore needs an update:</p><pre><code class="language-python">from typing import Optional


class InMemoryReentrantDatastore(InMemoryAuthenticatedDatastore):

    _log = logging.getLogger(&apos;InMemoryReentrantDatastore&apos;)
    _session_token: Optional[AuthToken] = None

    @contextmanager
    def _session(self):
        if self._session_token:
            yield
            return

        self._session_token = self._login(self.credentials)
        try:
            yield
        finally:
            self._logout(self._session_token)
</code></pre><p>If a session token exists, it means that we are already within the scope of the session context manager. Thus we simply yield to allow the caller to complete, and then return from the context manager. The context manager that initiated the session token is the only one allowed to log out.</p><pre><code class="language-python">&gt;&gt;&gt; from mock_datastore import InMemoryReentrantDatastore as MockDatastore
&gt;&gt;&gt; client = MockDatastore()
&gt;&gt;&gt; with client._session():
...     i = client.push(&apos;another entry&apos;)
...     client.pull(i)
...
DEBUG:InMemoryReentrantDatastore:LOGIN: -1271783380944662680
DEBUG:InMemoryReentrantDatastore:PUSH: db578045-674b-463f-9475-156315fcce29 with 13 bytes
DEBUG:InMemoryReentrantDatastore:PULL: db578045-674b-463f-9475-156315fcce29
&apos;another entry&apos;
DEBUG:InMemoryReentrantDatastore:LOGOUT: -1271783380944662680</code></pre><p>The session scope is now respected: there is only one session created for the <code>InMemoryReentrantDatastore._session()</code> context manager scope, no matter how many calls to methods requiring a session.</p><p>We should note that the current interface does not expose the session context manager as public to the library clients. Considering our contrived example, we can simply flatten the whole hierarchy and keep only one interface and one in-memory implementation. This is left as an exercise.</p><h2 id="conclusion">Conclusion</h2><p>Python context managers are an easy way to abstract resource management in libraries. Their simple form flows and is enough as long as they remain independent. Upgrading a context manager to be reentrant is a simple and efficient way to allow a scope to be shared, without changing the context semantics.</p><p><a href="https://www.python.org/dev/peps/pep-0318/">Decorators</a> are another powerful concept in Python. Our example uses the <a href="https://docs.python.org/3/library/contextlib.html#contextlib.contextmanager"><code>contextlib.contextmanager</code> decorator</a> to wrap a function and make it into a context manager.</p><p>Would you like to use the session context manager as a decorator too? Go on, try it! Try both approaches and see which one reads and writes better <em>from the library client.</em></p>]]></content:encoded></item><item><title><![CDATA[(Untitled)]]></title><description><![CDATA[<p>Ah! The joy of looking at a clean slate. Scary. Wondrous.</p><p>A clean and uncluttered editor helps focus on what matters: the prose. I might come to like this. Surrendering to the thoughts that come to life while keyed on the computer. It is a form of meditation.</p><p>Enough for</p>]]></description><link>https://steadymonkey.eu/untitled/</link><guid isPermaLink="false">6175c0545908100001910ba7</guid><category><![CDATA[Thoughts]]></category><dc:creator><![CDATA[Borjan Tchakaloff]]></dc:creator><pubDate>Sun, 01 Dec 2019 17:21:44 GMT</pubDate><content:encoded><![CDATA[<p>Ah! The joy of looking at a clean slate. Scary. Wondrous.</p><p>A clean and uncluttered editor helps focus on what matters: the prose. I might come to like this. Surrendering to the thoughts that come to life while keyed on the computer. It is a form of meditation.</p><p>Enough for now, I have to figure out if this interface can appear in French too. Not that it matters so much for what I want to do. Who knows, I might want to advocate for this platform to non tech-savvy people.</p><hr><p>No, really. This editor is the best I&apos;ve tried so far. Oh, I can even drag-n-drop blocks. Neat &#x263A;!</p><hr><p>It is a shame the interface is not translated. I suppose I&apos;ll just have to take the role of editor as well as publisher.</p>]]></content:encoded></item></channel></rss>